<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="AFL," />




  


  <link rel="alternate" href="/atom.xml" title="Sakuraのblog" type="application/atom+xml" />






<meta name="description" content="afl-gcc小叙核心函数find_as这个函数用来寻找afl-as的位置。  它首先检查是否存在AFL_PATH这个环境变量，如果存在就赋值给afl_path，然后检查afl_path&#x2F;as这个文件是否可以访问，如果可以访问，就将afl_path设置为as_path。 如果不存在AFL_PATH这个环境变量，则检查argv0，例如（”&#x2F;Users&#x2F;sakura&#x2F;gitsource&#x2F;AFL&#x2F;cma">
<meta property="og:type" content="article">
<meta property="og:title" content="sakuraのAFL源码全注释">
<meta property="og:url" content="http://eternalsakura13.com/2020/08/23/afl/index.html">
<meta property="og:site_name" content="Sakuraのblog">
<meta property="og:description" content="afl-gcc小叙核心函数find_as这个函数用来寻找afl-as的位置。  它首先检查是否存在AFL_PATH这个环境变量，如果存在就赋值给afl_path，然后检查afl_path&#x2F;as这个文件是否可以访问，如果可以访问，就将afl_path设置为as_path。 如果不存在AFL_PATH这个环境变量，则检查argv0，例如（”&#x2F;Users&#x2F;sakura&#x2F;gitsource&#x2F;AFL&#x2F;cma">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-08-03-083346.png">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-27-023812.jpg">
<meta property="article:published_time" content="2020-08-23T07:58:47.778Z">
<meta property="article:modified_time" content="2020-08-23T08:02:47.279Z">
<meta property="article:author" content="sakura">
<meta property="article:tag" content="AFL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-08-03-083346.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'QOPH9ID41Z',
      apiKey: '',
      indexName: 'sakura',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://eternalsakura13.com/2020/08/23/afl/"/>





  <title>sakuraのAFL源码全注释 | Sakuraのblog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113420358-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sakuraのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-buglist">
          <a href="/buglist/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            BugList
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2020/08/23/afl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sakura_heart.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">sakuraのAFL源码全注释</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-23T15:58:47+08:00">
                2020-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Fuzz/" itemprop="url" rel="index">
                    <span itemprop="name">Fuzz</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/23/afl/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/08/23/afl/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/08/23/afl/" class="leancloud_visitors" data-flag-title="sakuraのAFL源码全注释">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="afl-gcc小叙"><a href="#afl-gcc小叙" class="headerlink" title="afl-gcc小叙"></a>afl-gcc小叙</h2><h3 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h3><h4 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h4><p>这个函数用来寻找<code>afl-as</code>的位置。</p>
<ul>
<li>它首先检查是否存在AFL_PATH这个环境变量，如果存在就赋值给afl_path，然后检查<code>afl_path/as</code>这个文件是否可以访问，如果可以访问，就将afl_path设置为as_path。</li>
<li>如果不存在AFL_PATH这个环境变量，则检查argv0，例如（”/Users/sakura/gitsource/AFL/cmake-build-debug/afl-gcc”）中是否存在’/‘，如果有就找到最后一个’/‘所在的位置，并取其前面的字符串作为dir，然后检查<code>dir/afl-as</code>这个文件是否可以访问，如果可以访问，就将dir设置为as_path</li>
<li>如果上述两种方式都失败，则抛出异常。</li>
</ul>
<h4 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h4><p>这个函数主要是将argv拷贝到<code>u8 **cc_params</code>中，并做必要的编辑。</p>
<ul>
<li>它首先通过ck_alloc来为cc_params分配内存，分配的长度为<code>(argc+128)*8</code>，相当大的内存了。</li>
<li>然后检查argv[0]里有没有’/‘，如果没有就赋值’argv[0]’到name，如果有就找到最后一个’/‘所在的位置，然后跳过这个’/‘，将后面的字符串赋值给name。</li>
<li>将name和<code>afl-clang</code>比较<ul>
<li>如果相同，则设置clang_mode为1，然后设置环境变量CLANG_ENV_VAR为1。<ul>
<li>然后将name和<code>afl-clang++</code>比较<ul>
<li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为clang++</li>
<li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为clang</li>
</ul>
</li>
</ul>
</li>
<li>如果不相同，则将name和<code>afl-g++</code>比较<ul>
<li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为g++</li>
<li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为gcc</li>
</ul>
</li>
</ul>
</li>
<li>然后遍历从argv[1]开始的argv参数<ul>
<li>跳过<code>-B/integrated-as/-pipe</code></li>
<li>如果存在<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，就设置asan_set为1;</li>
<li>如果存在<code>FORTIFY_SOURCE</code>，则设置fortify_set为1</li>
<li><code>cc_params[cc_par_cnt++] = cur</code>;</li>
</ul>
</li>
<li>然后开始设置其他的cc_params参数<ul>
<li>取之前计算出来的<code>as_path</code>，然后设置<code>-B as_path</code></li>
<li>如果是clang_mode,则设置<code>-no-integrated-as</code></li>
<li>如果存在AFL_HARDEN环境变量，则设置<code>-fstack-protector-all</code></li>
<li>sanitizer<ul>
<li>如果asan_set在上面被设置为1，则使<code>AFL_USE_ASAN</code>环境变量为1</li>
<li>如果存在AFL_USE_ASAN环境变量，则设置<code>-fsanitize=address</code></li>
<li>如果存在AFL_USE_MSAN环境变量，则设置<code>-fsanitize=memory</code>，但不能同时还指定<code>AFL_HARDEN</code>或者<code>AFL_USE_ASAN</code>，因为这样运行时速度过慢。</li>
</ul>
</li>
<li>如果不存在AFL_DONT_OPTIMIZE环境变量，则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
<li>如果存在AFL_NO_BUILTIN环境变量，则设置<code>-fno-builtin-strcmp</code>等</li>
</ul>
</li>
<li>最后<code>cc_params[cc_par_cnt] = NULL;</code>终止对cc_params的编辑</li>
</ul>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>实际上看到这里，我们就知道afl-gcc就是找到as所在的位置，将其加入搜索路径，然后设置必要的gcc参数和一些宏，然后调用gcc进行实际的编译，仅仅只是一层wrapper</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">"AFL_QUIET"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(cCYA <span class="string">"afl-cc "</span> cBRI VERSION cRST <span class="string">" by &lt;lcamtuf@google.com&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找fake GNU assembler</span></span><br><span class="line">    find_as(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 设置CC的参数</span></span><br><span class="line">    edit_params(argc, argv);</span><br><span class="line">    <span class="comment">// 调用execvp来执行CC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里我们在CC之前打印一下参数看看。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cc_params); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\targ%d: %s\n"</span>,i,cc_params[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span> **) cc_params);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">"Oops, failed to execute '%s' - check your PATH"</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sakura@sakuradeMacBook-Pro:~&#x2F;gitsource&#x2F;AFL&#x2F;cmake-build-debug$ .&#x2F;afl-gcc ..&#x2F;test-instr.c -o test</span><br><span class="line">afl-cc 2.57b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">        arg0: gcc</span><br><span class="line">        arg1: ..&#x2F;test-instr.c</span><br><span class="line">        arg2: -o</span><br><span class="line">        arg3: test</span><br><span class="line">        arg4: -B</span><br><span class="line">        arg5: .</span><br><span class="line">        arg6: -g</span><br><span class="line">        arg7: -O3</span><br></pre></td></tr></table></figure>


<h2 id="afl-as小叙"><a href="#afl-as小叙" class="headerlink" title="afl-as小叙"></a>afl-as小叙</h2><h3 id="核心函数-1"><a href="#核心函数-1" class="headerlink" title="核心函数"></a>核心函数</h3><h4 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h4><p>检查并修改参数以传递给<code>as</code>。请注意，文件名始终是GCC传递的最后一个参数，因此我们利用这个特性使代码保持简单。<br><strong>主要是设置变量as_params的值，以及use_64bit/modified_file的值。</strong></p>
<ul>
<li>首先为as_params分配空间，大小为<code>(argc+32)*8</code></li>
<li><code>u8 *tmp_dir</code><ul>
<li>依次检查是否存在TMPDIR/TEMP/TMP环境变量，如果存在就设置，如果都不存在就设置tmp_dir为”/tmp”</li>
</ul>
</li>
<li><code>u8 *afl_as</code><ul>
<li>读取AFL_AS环境变量，如果存在就设置为afl_as的值</li>
<li>因为apple的一些原因，所以如果我们定义了<code>__APPLE__</code>宏，且当前是在clang_mode且没有设置AFL_AS环境变量，就设置use_clang_as为1，并设置afl_as为AFL_CC/AFL_CXX/clang中的一种。</li>
</ul>
</li>
<li>如果afl_as不为空，就设置<code>as_params[0]</code>为<code>afl_as</code>，否则设置为<code>as</code></li>
<li>设置<code>as_params[argc]</code>为0,as_par_cnt初始值为1。</li>
<li>然后遍历从argv[1]开始,到<code>argv[argc-1]</code>(也就是最后一个参数)之前的argv参数<ul>
<li>如果存在<code>--64</code>，设置use_64bit为1，如果存在<code>--32</code>，设置use_64bit为0;如果是apple,则如果存在<code>-arch x86_64</code>,设置use_64bit为1,并跳过<code>-q</code>和<code>-Q</code>选项</li>
<li><code>as_params[as_par_cnt++] = argv[i]</code>;设置as_params的值为argv对应的参数值</li>
</ul>
</li>
<li>然后开始设置其他的as_params参数<ul>
<li>如果use_clang_as为1，则设置<code>-c -x assembler</code>选项</li>
<li>读取<code>argv[argc - 1]</code>的值,赋给input_file的值,也就是传递的最后一个参数的值作为input_file</li>
<li>比较input_file和tmp_dir/<code>/var/tmp/</code>/<code>/tmp/</code>的前strlen(tmp_dir)/9/5个字节是否相同，如果不相同，就设置pass_thru为1</li>
<li>设置modified_file的值为<code>alloc_printf(&quot;%s/.afl-%u-%u.s&quot;, tmp_dir, getpid(),(u32) time(NULL));</code>,简单的说就是<code>tmp_dir/.afl-pid-time.s</code>这样的字符串。</li>
<li>设置<code>as_params[as_par_cnt++] = modified_file</code></li>
<li><code>as_params[as_par_cnt] = NULL;</code></li>
</ul>
</li>
</ul>
<h4 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h4><p>处理输入文件，生成modified_file，将instrumentation插入所有适当的位置。</p>
<ul>
<li>如果input_file不为空，则尝试打开这个文件，如果打开失败就抛出异常，如果为空，则读取标准输入，最终获取FILE* 指针inf</li>
<li>然后打开modified_file对应的临时文件，并获取其句柄outfd，再根据句柄通过fdopen函数拿到FILE*指针outf</li>
<li>通过fgets从inf中逐行读取内容保存到line数组里，每行最多读取的字节数是MAX_LINE(8192),这个值包括’\0’,所以实际读取的有内容的字节数是MAX_LINE-1个字节。从line数组里将读取的内容写入到outf对应的文件里。</li>
</ul>
<p><strong>接下来是真正有趣的部分，首先我们要确定的是，我们只在.text部分进行插桩，但因为这部分涉及到多平台以及优化后的汇编文件格式，这里我只会描述最核心的逻辑</strong></p>
<p>核心逻辑如下,我抽取了最重要的代码出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ^func:      - function entry point (always instrumented)</span><br><span class="line">  ^.L0:       - GCC branch label</span><br><span class="line">  ^.LBB0_0:   - clang branch label (but only in clang mode)</span><br><span class="line">  ^\tjnz foo  - conditional branches</span><br><span class="line"></span><br><span class="line">...but not:</span><br><span class="line"></span><br><span class="line">  ^# BB#0:    - clang comments</span><br><span class="line">  ^ # BB#0:   - ditto</span><br><span class="line">  ^.Ltmp0:    - clang non-branch labels</span><br><span class="line">  ^.LC0       - GCC non-branch labels</span><br><span class="line">  ^.LBB0_0:   - ditto (when in GCC mode)</span><br><span class="line">  ^\tjmp foo  - non-conditional jumps</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(<span class="built_in">line</span>, MAX_LINE, inf)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(instr_ok &amp;&amp; instrument_next &amp;&amp; <span class="built_in">line</span>[<span class="number">0</span>] == <span class="string">'\t'</span> &amp;&amp; <span class="built_in">isalpha</span>(<span class="built_in">line</span>[<span class="number">1</span>]))&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                    R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">0</span>;</span><br><span class="line">        ins_lines++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">line</span>[<span class="number">0</span>] == <span class="string">'\t'</span> &amp;&amp; <span class="built_in">line</span>[<span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"text\n"</span>, <span class="number">5</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"section\t.text"</span>, <span class="number">13</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"section\t__TEXT,__text"</span>, <span class="number">21</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"section __TEXT,__text"</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">            instr_ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"section\t"</span>, <span class="number">8</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"section "</span>, <span class="number">8</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"bss\n"</span>, <span class="number">4</span>) ||</span><br><span class="line">            !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">2</span>, <span class="string">"data\n"</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">            instr_ok = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">line</span>[<span class="number">0</span>] == <span class="string">'\t'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">line</span>[<span class="number">1</span>] == <span class="string">'j'</span> &amp;&amp; <span class="built_in">line</span>[<span class="number">2</span>] != <span class="string">'m'</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                        R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">                ins_lines++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(<span class="built_in">line</span>, <span class="string">":"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">line</span>[<span class="number">0</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(<span class="built_in">line</span>[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(<span class="built_in">line</span> + <span class="number">1</span>, <span class="string">"LBB"</span>, <span class="number">3</span>)))</span><br><span class="line">                        &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">                            instrument_next = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line">            instrument_next = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>检查<code>instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == &#39;\t&#39; &amp;&amp; isalpha(line[1])</code>即判断instrument_next和instr_ok是否都为1，以及line是否以<code>\t</code>开始，且<code>line[1]</code>是否是字母</p>
<ul>
<li>如果都满足，则设置<code>instrument_next = 0</code>,并向outf中写入<code>trampoline_fmt</code>，并将插桩计数器<code>ins_lines</code>加一。</li>
<li>这其实是因为我们想要插入instrumentation trampoline到所有的标签，宏，注释之后。</li>
</ul>
</li>
<li><p>首先要设置instr_ok的值，这个值其实是一个flag，只有这个值被设置为1，才代表我们在<code>.text</code>部分，否则就不在。于是如果instr_ok为1，就会在分支处执行插桩逻辑，否则就不插桩。</p>
<ul>
<li>如果line的值为<code>\t.[text\n|section\t.text|section\t__TEXT,__text|section __TEXT,__text]...</code>其中之一，则设置instr_ok为1，然后跳转到while循环首部，去读取下一行的数据到line数组里。</li>
<li>如果不是上面的几种情况，且line的值为<code>\t.[section\t|section |bss\n|data\n]...</code>，则设置instr_ok为0，并跳转到while循环首部，去读取下一行的数据到line数组里。</li>
</ul>
</li>
<li><p>插桩<code>^\tjnz foo</code>条件跳转指令</p>
<ul>
<li>如果line的值为<code>\tj[!m]...</code>,且<code>R(100) &lt; inst_ratio</code>，R(100)会返回一个100以内的随机数，inst_ratio是我们之前设置的插桩密度，默认为100，如果设置了asan之类的就会默认设置成30左右。</li>
<li><code>fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</code>根据use_64bit来判断向outfd里写入trampoline_fmt_64还是trampoline_fmt_32。<ul>
<li><code>define R(x) (random() % (x))</code>，可以看到R(x)是创建的随机数除以x取余，所以可能产生碰撞</li>
<li>这里的R(x)实际上是用来区分每个桩的，也就是是一个标识。后文会再说明。</li>
</ul>
</li>
<li>将插桩计数器<code>ins_lines</code>加一。</li>
</ul>
</li>
<li><p>首先检查该行中是否存在<code>:</code>，然后检查是否以<code>.开始</code></p>
<ul>
<li>如果以<code>.</code>开始，则代表想要插桩<code>^.L0:</code>或者<code>^.LBB0_0:</code>这样的branch label，即style jump destination<ul>
<li>然后检查<code>line[2]</code>是否为数字 或者 如果是在clang_mode下，比较从line[1]开始的三个字节是否为LBB. 前述所得结果和<code>R(100) &lt; inst_ratio)</code>相与。<ul>
<li>如果结果为真，则设置<code>instrument_next = 1</code></li>
</ul>
</li>
</ul>
</li>
<li>否则代表这是一个function，插桩<code>^func:</code>function entry point<ul>
<li>直接设置<code>instrument_next = 1</code></li>
</ul>
</li>
</ul>
</li>
<li><p>如果插桩计数器ins_lines不为0，就在完全拷贝input_file之后，依据架构，像outf中写入main_payload_64或者main_payload_32，然后关闭这两个文件</p>
</li>
<li><p><strong>至此我们可以看出afl的插桩相当简单粗暴，就是通过汇编的前导命令来判断这是否是一个分支或者函数，然后插入instrumentation trampoline。</strong></p>
</li>
<li><p><strong>关于instrumentation trampoline，后文叙述</strong></p>
</li>
</ul>
<h4 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h4><p>最后我们回来看一下main函数</p>
<ul>
<li>读取环境变量AFL_INST_RATIO的值，设置为inst_ratio_str</li>
<li>设置srandom的随机种子为<code>rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</code></li>
<li>设置环境变量AS_LOOP_ENV_VAR的值为1</li>
<li>读取环境变量AFL_USE_ASAN和AFL_USE_MSAN的值，如果其中有一个为1，则设置sanitizer为1，且将inst_ratio除3。<ul>
<li>这是因为AFL无法在插桩的时候识别出ASAN specific branches，所以会插入很多无意义的桩，为了降低这种概率，粗暴的将整个插桩的概率都除以3</li>
</ul>
</li>
<li>edit_params(argc, argv)</li>
<li>add_instrumentation()</li>
<li>fork出一个子进程，让子进程来执行<code>execvp(as_params[0], (char **) as_params);</code><ul>
<li>这其实是因为我们的execvp执行的时候，会用<code>as_params[0]</code>来完全替换掉当前进程空间中的程序，如果不通过子进程来执行实际的as，那么后续就无法在执行完实际的as之后，还能unlink掉modified_file</li>
<li><a href="https://www.cnblogs.com/mickole/p/3187409.html" target="_blank" rel="noopener">exec系列函数</a></li>
<li><a href="https://blog.csdn.net/THEONE10211024/article/details/13774669" target="_blank" rel="noopener">fork出的子进程和父进程</a></li>
</ul>
</li>
<li><code>waitpid(pid, &amp;status, 0)</code>等待子进程结束</li>
<li>读取环境变量AFL_KEEP_ASSEMBLY的值，如果没有设置这个环境变量，就unlink掉modified_file。</li>
</ul>
<p>稍微打印一下参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(as_params); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"as_params[%d]:%s\n"</span>, i, as_params[i]);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">[+] Instrumented <span class="number">5</span> locations (<span class="number">64</span>-<span class="built_in">bit</span>, non-hardened mode, ratio <span class="number">100</span>%).</span><br><span class="line">as_params[<span class="number">0</span>]:as</span><br><span class="line">as_params[<span class="number">1</span>]:/Users/sakura/gitsource/AFL/cmake-build-debug/tmp/afl<span class="number">-8427</span><span class="number">-1595314986.</span>s</span><br></pre></td></tr></table></figure>

<h2 id="afl-fast-clang中叙"><a href="#afl-fast-clang中叙" class="headerlink" title="afl-fast-clang中叙"></a>afl-fast-clang中叙</h2><p>因为AFL对于上述通过<code>afl-gcc</code>来插桩这种做法已经属于不建议，并提供了更好的工具afl-clang-fast，通过llvm pass来插桩。</p>
<h3 id="clang-wrapper"><a href="#clang-wrapper" class="headerlink" title="clang wrapper"></a>clang wrapper</h3><p><code>afl-clang-fast.c</code>这个文件其实是clang的一层wrapper，和之前的<code>afl-gcc</code>一样，只是定义了一些宏，和传递了一些参数给真正的clang。<br>我们还是依次来看一下核心函数。</p>
<h4 id="find-obj"><a href="#find-obj" class="headerlink" title="find_obj"></a>find_obj</h4><ul>
<li>获取环境变量<code>AFL_PATH</code>的值，如果存在，就去读取<code>AFL_PATH/afl-llvm-rt.o</code>是否可以访问，如果可以就设置这个目录为<code>obj_path</code>，然后直接返回</li>
<li>如果没有设置这个环境变量，就检查arg0中是否存在<code>/</code>，例如我们可能是通过<code>/home/sakura/AFL/afl-clang-fast</code>去调用afl-clang-fast的，所以它此时就认为最后一个<code>/</code>之前的<code>/home/sakura/AFL</code>是AFL的根目录，然后读取其下的<code>afl-llvm-rt.o</code>文件，看是否能够访问，如果可以就设置这个目录为<code>obj_path</code>，然后直接返回。</li>
<li>最后如果上面两种都找不到，因为默认的AFL的MakeFile在编译的时候，会定义一个名为<code>AFL_PATH</code>的宏，其指向<code>/usr/local/lib/afl</code>,会到这里找是否存在<code>afl-llvm-rt.o</code>，如果存在设置<code>obj_path</code>并直接返回。</li>
<li>如果上述三种方式都找不到，那么就会抛出异常<code>Unable to find &#39;afl-llvm-rt.o&#39; or &#39;afl-llvm-pass.so&#39;. Please set AFL_PATH</code></li>
</ul>
<h4 id="edit-params-2"><a href="#edit-params-2" class="headerlink" title="edit_params"></a>edit_params</h4><ul>
<li>首先根据我们执行的是<code>afl-clang-fast</code>还是<code>afl-clang-fast++</code>来决定<code>cc_params[0]</code>的值是clang++还是clang。<ul>
<li>如果执行的是<code>afl-clang-fast++</code>，读取环境变量<code>AFL_CXX</code>，如果存在，就将其值设置为<code>cc_params[0]</code>，如果不存在，就直接设置成<code>clang++</code></li>
<li>如果执行的是<code>afl-clang-fast</code>，读取环境变量<code>AFL_CC</code>，如果存在，就将其值设置为<code>cc_params[0]</code>，如果不存在，就直接设置成<code>clang</code></li>
</ul>
</li>
<li>默认情况下，我们通过<code>afl-llvm-pass.so</code>来注入instrumentation，但是现在也支持<code>trace-pc-guard</code>模式，可以参考<a href="http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards" target="_blank" rel="noopener">llvm的文档</a></li>
<li>然后如果定义了<code>USE_TRACE_PC</code>宏，就将<code>-fsanitize-coverage=trace-pc-guard -mllvm -sanitizer-coverage-block-threshold=0</code>添加到参数里</li>
<li>如果没有定义，就依次将<code>-Xclang -load -Xclang obj_path/afl-llvm-pass.so -Qunused-arguments</code></li>
<li>依次读取我们传给<code>afl-clang-fast</code>的参数，并添加到cc_params里，不过这里会做一些检查和设置。<ul>
<li>如果传入参数里有<code>-m32</code>或者<code>armv7a-linux-androideabi</code>，就设置<code>bit_mode</code>为32</li>
<li>如果传入参数里有<code>-m64</code>，就设置<code>bit_mode</code>为64</li>
<li>如果传入参数里有<code>-x</code>，就设置<code>x_set</code>为1</li>
<li>如果传入参数里有<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，就设置asan_set为1</li>
<li>如果传入参数里有<code>-Wl,-z,defs</code>或者<code>-Wl,--no-undefined</code>，就直接pass掉，不传给clang。</li>
</ul>
</li>
<li>读取环境变量<code>AFL_HARDEN</code>，如果存在，就在cc_params里添加<code>-fstack-protector-all</code></li>
<li>如果参数里没有<code>-fsanitize=address/memory</code>，即asan_set是0，就读取环境变量<code>AFL_USE_ASAN</code>，如果存在就添加<code>-fsanitize=address</code>到cc_params里，环境变量<code>AFL_USE_MSAN</code>同理</li>
<li>如果定义了<code>USE_TRACE_PC</code>宏，就检查是否存在环境变量<code>AFL_INST_RATIO</code>，如果存在就抛出异常<code>AFL_INST_RATIO not available at compile time with &#39;trace-pc&#39;.</code></li>
<li>读取环境变量<code>AFL_DONT_OPTIMIZE</code>，如果<strong>不存在</strong>就添加<code>-g -O3 -funroll-loops</code>到参数里</li>
<li>读取环境变量<code>AFL_NO_BUILTIN</code>，如果存在就添加<code>-fno-builtin-strcmp</code>等。</li>
<li>添加参数<code>-D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code>，定义一些宏</li>
<li>这里定义了如下两个宏<code>__AFL_LOOP</code>,<code>__AFL_INIT()</code>,宏展开是类似这样的，为简化我去掉了和编译器优化相关的东西。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AFL_LOOP() \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> *_B; \</span><br><span class="line">      _B = (<span class="keyword">char</span>*)<span class="string">"##SIG_AFL_PERSISTENT##"</span>; \</span><br><span class="line">      __afl_persistent_loop(); \</span><br><span class="line">  &#125;<span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AFL_INIT() \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> *_A;  \</span><br><span class="line">      _A = (<span class="keyword">char</span>*)<span class="string">"##SIG_AFL_DEFER_FORKSRV##"</span>; \</span><br><span class="line">      __afl_manual_init(); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果x_set为1，则添加参数<code>-x none</code></li>
<li>根据<code>bit_mode</code>的值选择<code>afl-llvm-rt</code><ul>
<li>如果为0，即没有<code>-m32</code>和<code>-m64</code>选项，就向参数里添加<code>obj_path/afl-llvm-rt.o</code></li>
<li>如果为32，添加<code>obj_path/afl-llvm-rt-32.o</code></li>
<li>如果为64，添加<code>obj_path/afl-llvm-rt-64.o</code></li>
</ul>
</li>
</ul>
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><ul>
<li>寻找obj_path路径</li>
<li>编辑参数cc_params</li>
<li>替换进程空间，执行要调用的clang和为其传递参数<ul>
<li><code>execvp(cc_params[0], (char**)cc_params);</code><h3 id="afl-llvm-pass"><a href="#afl-llvm-pass" class="headerlink" title="afl-llvm-pass"></a>afl-llvm-pass</h3>关于llvm不懂的可以看CSCD70，顺便可以学一下优化，这里放一下我之前抽空做的<a href="https://github.com/eternalsakura/sakura_llvm_opt" target="_blank" rel="noopener">笔记</a>, 以及<a href="https://blog.csdn.net/qq_23599965/article/details/88538590" target="_blank" rel="noopener">这篇文章</a>可以列为查询和参考.<br>afl-llvm-pass里只有一个Transform pass AFLCoverage，其继承自ModulePass，所以我们主要分析一下它的<code>runOnModule</code>函数，这里简单的介绍一下llvm里的一些层次关系，粗略理解就是Module相当于你的程序，里面包含所有Function和全局变量，而Function里包含所有BasicBlock和函数参数，BasicBlock里包含所有Instruction,Instruction包含Opcode和Operands。<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-08-03-083346.png" alt=""><h4 id="注册pass"><a href="#注册pass" class="headerlink" title="注册pass"></a>注册pass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAFLPass</span><span class="params">(<span class="keyword">const</span> PassManagerBuilder &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                            legacy::PassManagerBase &amp;PM)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  PM.add(<span class="keyword">new</span> AFLCoverage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">RegisterAFLPass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">RegisterAFLPass0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass)</span></span>;</span><br></pre></td></tr></table></figure>
这些都是向PassManager来注册新的pass，每个pass彼此独立，通过PM统一注册和调度，更加模块化。<br>具体的可以参考定义，我摘取了必要的代码和注释，请仔细阅读。<br>简单的理解就是当我创建了一个类RegisterStandardPasses之后，就会调用它的构造函数，然后调用<code>PassManagerBuilder::addGlobalExtension</code>，这是一个静态函数，这个函数会创建一个tuple保存<strong>Ty和Fn还有一个id</strong>，并将其添加到一个静态全局vector里，以供PassManagerBuilder在需要的时候，将其添加到PM里。<br>而这个添加的时机就是<code>ExtensionPointTy</code>来指定的。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Registers a function for adding a standard set of passes.  This should be</span></span><br><span class="line"><span class="comment">/// used by optimizer plugins to allow all front ends to transparently use</span></span><br><span class="line"><span class="comment">/// them.  Create a static instance of this class in your plugin, providing a</span></span><br><span class="line"><span class="comment">/// private function that the PassManagerBuilder can use to add your passes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterStandardPasses</span> &#123;</span></span><br><span class="line">  PassManagerBuilder::GlobalExtensionID ExtensionID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  RegisterStandardPasses(PassManagerBuilder::ExtensionPointTy Ty,</span><br><span class="line">                         PassManagerBuilder::ExtensionFn Fn) &#123;</span><br><span class="line">    ExtensionID = PassManagerBuilder::addGlobalExtension(Ty, <span class="built_in">std</span>::<span class="built_in">move</span>(Fn));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~RegisterStandardPasses() &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/// PassManagerBuilder - This class is used to set up a standard optimization</span></span><br><span class="line"><span class="comment">/// sequence for languages like C and C++, allowing some APIs to customize the</span></span><br><span class="line"><span class="comment">/// pass sequence in various ways. A simple example of using it would be:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  PassManagerBuilder Builder;</span></span><br><span class="line"><span class="comment">///  Builder.OptLevel = 2;</span></span><br><span class="line"><span class="comment">///  Builder.populateFunctionPassManager(FPM);</span></span><br><span class="line"><span class="comment">///  Builder.populateModulePassManager(MPM);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In addition to setting up the basic passes, PassManagerBuilder allows</span></span><br><span class="line"><span class="comment">/// frontends to vend a plugin API, where plugins are allowed to add extensions</span></span><br><span class="line"><span class="comment">/// to the default pass manager.  They do this by specifying where in the pass</span></span><br><span class="line"><span class="comment">/// pipeline they want to be added, along with a callback function that adds</span></span><br><span class="line"><span class="comment">/// the pass(es).  For example, a plugin that wanted to add a loop optimization</span></span><br><span class="line"><span class="comment">/// could do something like this:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// static void addMyLoopPass(const PMBuilder &amp;Builder, PassManagerBase &amp;PM) &#123;</span></span><br><span class="line"><span class="comment">///   if (Builder.getOptLevel() &gt; 2 &amp;&amp; Builder.getOptSizeLevel() == 0)</span></span><br><span class="line"><span class="comment">///     PM.add(createMyAwesomePass());</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">///   ...</span></span><br><span class="line"><span class="comment">///   Builder.addExtension(PassManagerBuilder::EP_LoopOptimizerEnd,</span></span><br><span class="line"><span class="comment">///                        addMyLoopPass);</span></span><br><span class="line"><span class="comment">///   ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassManagerBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Extensions are passed to the builder itself (so they can see how it is</span></span><br><span class="line">  <span class="comment">/// configured) as well as the pass manager to add stuff to.</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> PassManagerBuilder &amp;Builder,</span><br><span class="line">                             legacy::PassManagerBase &amp;PM)&gt;</span><br><span class="line">      ExtensionFn;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">int</span> GlobalExtensionID;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> ExtensionPointTy &#123;</span><br><span class="line">    <span class="comment">/// EP_ModuleOptimizerEarly - This extension point allows adding passes</span></span><br><span class="line">    <span class="comment">/// just before the main module-level optimization passes.</span></span><br><span class="line">    EP_ModuleOptimizerEarly,</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// EP_EnabledOnOptLevel0 - This extension point allows adding passes that</span></span><br><span class="line">    <span class="comment">/// should not be disabled by O0 optimization level. The passes will be</span></span><br><span class="line">    <span class="comment">/// inserted after the inlining pass.</span></span><br><span class="line">    EP_EnabledOnOptLevel0,</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/// Adds an extension that will be used by all PassManagerBuilder instances.</span></span><br><span class="line">  <span class="comment">/// This is intended to be used by plugins, to register a set of</span></span><br><span class="line">  <span class="comment">/// optimisations to run automatically.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// \returns A global extension identifier that can be used to remove the</span></span><br><span class="line">  <span class="comment">/// extension.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GlobalExtensionID <span class="title">addGlobalExtension</span><span class="params">(ExtensionPointTy Ty,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ExtensionFn Fn)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// PassManagerBase - An abstract interface to allow code to add passes to</span></span><br><span class="line"><span class="comment">/// a pass manager without having to hard-code what kind of pass manager</span></span><br><span class="line"><span class="comment">/// it is.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassManagerBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~PassManagerBase();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Add a pass to the queue of passes to run.  This passes ownership of</span></span><br><span class="line">  <span class="comment">/// the Pass to the PassManager.  When the PassManager is destroyed, the pass</span></span><br><span class="line">  <span class="comment">/// will be destroyed as well, so there is no need to delete the pass.  This</span></span><br><span class="line">  <span class="comment">/// may even destroy the pass right away if it is found to be redundant. This</span></span><br><span class="line">  <span class="comment">/// implies that all passes MUST be allocated with 'new'.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Pass *P)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="runOnModule"><a href="#runOnModule" class="headerlink" title="runOnModule"></a>runOnModule</h4><ul>
<li>通过getContext来获取LLVMContext，其保存了整个程序里分配的类型和常量信息。</li>
<li>通过这个Context来获取type实例Int8Ty和Int32Ty<ul>
<li>Type是所有type类的一个超类。<strong>每个Value都有一个Type</strong>，所以这经常被用于寻找指定类型的Value。Type不能直接实例化，只能通过其子类实例化。某些基本类型(VoidType、LabelType、FloatType和DoubleType)有隐藏的子类。之所以隐藏它们，是因为除了Type类提供的功能之外，它们没有提供任何有用的功能，除了将它们与Type的其他子类区分开来之外。所有其他类型都是DerivedType的子类。Types可以被命名，但这不是必需的。一个给定Type在任何时候都只存在一个实例。这允许使用Type实例的地址相等来执行type相等。也就是说，给定两个Type*值，如果指针相同，则types相同。</li>
</ul>
</li>
<li>读取环境变量AFL_INST_RATIO给变量inst_ratio，其值默认为100，这个值代表一个插桩概率，本来应该每个分支都必定插桩，而这是一个随机的概率决定是否要在这个分支插桩。</li>
<li>获取全局变量中指向共享内存的指针，以及上一个基础块的编号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">        <span class="keyword">new</span> GlobalVariable(M, PointerType::<span class="built_in">get</span>(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                            GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">"__afl_area_ptr"</span>);</span><br><span class="line"></span><br><span class="line">GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> GlobalVariable(</span><br><span class="line">        M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">"__afl_prev_loc"</span>,</span><br><span class="line">        <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
<li>遍历每个基本块，找到此基本块中适合插入instrument的位置，后续通过初始化IRBuilder的一个实例进行插入。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock::iterator IP &#x3D; BB.getFirstInsertionPt();</span><br><span class="line">IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br></pre></td></tr></table></figure></li>
<li>随机创建一个当前基本块的编号，并通过插入load指令来获取前一个基本块的编号。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cur_loc = AFL_R(MAP_SIZE);</span><br><span class="line">ConstantInt *CurLoc = ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc);</span><br><span class="line">LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);</span><br><span class="line">PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());</span><br></pre></td></tr></table></figure></li>
<li>通过插入load指令来获取共享内存的地址，并通过CreateGEP函数来获取共享内存里指定index的地址，这个index通过cur_loc和prev_loc取xor计算得到。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);</span><br><span class="line">MapPtr-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">Value *MapPtrIdx =</span><br><span class="line">        IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));</span><br></pre></td></tr></table></figure></li>
<li>通过插入load指令来读取对应index地址的值，并通过插入add指令来将其加一，然后通过创建store指令将新值写入，更新共享内存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);</span><br><span class="line">Counter-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">Value *Incr = IRB.CreateAdd(Counter, ConstantInt::<span class="built_in">get</span>(Int8Ty, <span class="number">1</span>));</span><br><span class="line">IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">        -&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br></pre></td></tr></table></figure></li>
<li>将当前cur_loc的值右移一位，然后通过插入store指令，更新<code>__afl_prev_loc</code>的值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StoreInst *Store = IRB.CreateStore(ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">Store-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br></pre></td></tr></table></figure></li>
<li>总结<br>总的来说就是通过遍历每个基本块，向其中插入实现了如下伪代码功能的instruction ir来进行插桩。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;; </span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
看一个例子</li>
<li>源程序<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">8</span>) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hum?\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Looks like a zero to me!\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A non-zero value? How quaint!\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>插桩前的ir<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;nopt_test-instr.ll&#39;</span><br><span class="line">source_filename &#x3D; &quot;test-instr.c&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [6 x i8] c&quot;Hum?\0A\00&quot;, align 1</span><br><span class="line">@.str.1 &#x3D; private unnamed_addr constant [26 x i8] c&quot;Looks like a zero to me!\0A\00&quot;, align 1</span><br><span class="line">@.str.2 &#x3D; private unnamed_addr constant [31 x i8] c&quot;A non-zero value? How quaint!\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind ssp uwtable</span><br><span class="line">define i32 @main(i32 %0, i8** %1) #0 &#123;</span><br><span class="line">  %3 &#x3D; alloca [8 x i8], align 1</span><br><span class="line">  %4 &#x3D; getelementptr inbounds [8 x i8], [8 x i8]* %3, i64 0, i64 0</span><br><span class="line">  %5 &#x3D; call i64 @&quot;\01_read&quot;(i32 0, i8* %4, i64 8)</span><br><span class="line">  %6 &#x3D; icmp slt i64 %5, 1</span><br><span class="line">  br i1 %6, label %7, label %9</span><br><span class="line"></span><br><span class="line">7:                                                ; preds &#x3D; %2</span><br><span class="line">  %8 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))</span><br><span class="line">  call void @exit(i32 1) #3</span><br><span class="line">  unreachable</span><br><span class="line"></span><br><span class="line">9:                                                ; preds &#x3D; %2</span><br><span class="line">  %10 &#x3D; getelementptr inbounds [8 x i8], [8 x i8]* %3, i64 0, i64 0</span><br><span class="line">  %11 &#x3D; load i8, i8* %10, align 1</span><br><span class="line">  %12 &#x3D; sext i8 %11 to i32</span><br><span class="line">  %13 &#x3D; icmp eq i32 %12, 48</span><br><span class="line">  br i1 %13, label %14, label %16</span><br><span class="line"></span><br><span class="line">14:                                               ; preds &#x3D; %9</span><br><span class="line">  %15 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i64 0, i64 0))</span><br><span class="line">  br label %18</span><br><span class="line"></span><br><span class="line">16:                                               ; preds &#x3D; %9</span><br><span class="line">  %17 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2, i64 0, i64 0))</span><br><span class="line">  br label %18</span><br><span class="line"></span><br><span class="line">18:                                               ; preds &#x3D; %16, %14</span><br><span class="line">  call void @exit(i32 0) #3</span><br><span class="line">  unreachable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i64 @&quot;\01_read&quot;(i32, i8*, i64) #1</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noreturn</span><br><span class="line">declare void @exit(i32) #2</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline nounwind ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #2 &#x3D; &#123; noreturn &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #3 &#x3D; &#123; noreturn &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!2&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!2 &#x3D; !&#123;!&quot;clang version 10.0.0 &quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>插桩后的ir<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;m2r_nopt_test-instr.ll&#39;</span><br><span class="line">source_filename &#x3D; &quot;test-instr.c&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [6 x i8] c&quot;Hum?\0A\00&quot;, align 1</span><br><span class="line">@.str.1 &#x3D; private unnamed_addr constant [26 x i8] c&quot;Looks like a zero to me!\0A\00&quot;, align 1</span><br><span class="line">@.str.2 &#x3D; private unnamed_addr constant [31 x i8] c&quot;A non-zero value? How quaint!\0A\00&quot;, align 1</span><br><span class="line">@__afl_area_ptr &#x3D; external global i8*</span><br><span class="line">@__afl_prev_loc &#x3D; external thread_local global i32</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind ssp uwtable</span><br><span class="line">define i32 @main(i32 %0, i8** %1) #0 &#123;</span><br><span class="line">  %3 &#x3D; load i32, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %4 &#x3D; load i8*, i8** @__afl_area_ptr, !nosanitize !3</span><br><span class="line">  %5 &#x3D; xor i32 %3, 17767</span><br><span class="line">  %6 &#x3D; getelementptr i8, i8* %4, i32 %5</span><br><span class="line">  %7 &#x3D; load i8, i8* %6, !nosanitize !3</span><br><span class="line">  %8 &#x3D; add i8 %7, 1</span><br><span class="line">  store i8 %8, i8* %6, !nosanitize !3</span><br><span class="line">  store i32 8883, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %9 &#x3D; alloca [8 x i8], align 1</span><br><span class="line">  %10 &#x3D; getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 0</span><br><span class="line">  %11 &#x3D; call i64 @&quot;\01_read&quot;(i32 0, i8* %10, i64 8)</span><br><span class="line">  %12 &#x3D; icmp slt i64 %11, 1</span><br><span class="line">  br i1 %12, label %13, label %21</span><br><span class="line"></span><br><span class="line">13:                                               ; preds &#x3D; %2</span><br><span class="line">  %14 &#x3D; load i32, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %15 &#x3D; load i8*, i8** @__afl_area_ptr, !nosanitize !3</span><br><span class="line">  %16 &#x3D; xor i32 %14, 9158</span><br><span class="line">  %17 &#x3D; getelementptr i8, i8* %15, i32 %16</span><br><span class="line">  %18 &#x3D; load i8, i8* %17, !nosanitize !3</span><br><span class="line">  %19 &#x3D; add i8 %18, 1</span><br><span class="line">  store i8 %19, i8* %17, !nosanitize !3</span><br><span class="line">  store i32 4579, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %20 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))</span><br><span class="line">  call void @exit(i32 1) #3</span><br><span class="line">  unreachable</span><br><span class="line"></span><br><span class="line">21:                                               ; preds &#x3D; %2</span><br><span class="line">  %22 &#x3D; load i32, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %23 &#x3D; load i8*, i8** @__afl_area_ptr, !nosanitize !3</span><br><span class="line">  %24 &#x3D; xor i32 %22, 39017</span><br><span class="line">  %25 &#x3D; getelementptr i8, i8* %23, i32 %24</span><br><span class="line">  %26 &#x3D; load i8, i8* %25, !nosanitize !3</span><br><span class="line">  %27 &#x3D; add i8 %26, 1</span><br><span class="line">  store i8 %27, i8* %25, !nosanitize !3</span><br><span class="line">  store i32 19508, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %28 &#x3D; getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 0</span><br><span class="line">  %29 &#x3D; load i8, i8* %28, align 1</span><br><span class="line">  %30 &#x3D; sext i8 %29 to i32</span><br><span class="line">  %31 &#x3D; icmp eq i32 %30, 48</span><br><span class="line">  br i1 %31, label %32, label %40</span><br><span class="line"></span><br><span class="line">32:                                               ; preds &#x3D; %21</span><br><span class="line">  %33 &#x3D; load i32, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %34 &#x3D; load i8*, i8** @__afl_area_ptr, !nosanitize !3</span><br><span class="line">  %35 &#x3D; xor i32 %33, 18547</span><br><span class="line">  %36 &#x3D; getelementptr i8, i8* %34, i32 %35</span><br><span class="line">  %37 &#x3D; load i8, i8* %36, !nosanitize !3</span><br><span class="line">  %38 &#x3D; add i8 %37, 1</span><br><span class="line">  store i8 %38, i8* %36, !nosanitize !3</span><br><span class="line">  store i32 9273, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %39 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i64 0, i64 0))</span><br><span class="line">  br label %48</span><br><span class="line"></span><br><span class="line">40:                                               ; preds &#x3D; %21</span><br><span class="line">  %41 &#x3D; load i32, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %42 &#x3D; load i8*, i8** @__afl_area_ptr, !nosanitize !3</span><br><span class="line">  %43 &#x3D; xor i32 %41, 56401</span><br><span class="line">  %44 &#x3D; getelementptr i8, i8* %42, i32 %43</span><br><span class="line">  %45 &#x3D; load i8, i8* %44, !nosanitize !3</span><br><span class="line">  %46 &#x3D; add i8 %45, 1</span><br><span class="line">  store i8 %46, i8* %44, !nosanitize !3</span><br><span class="line">  store i32 28200, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %47 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2, i64 0, i64 0))</span><br><span class="line">  br label %48</span><br><span class="line"></span><br><span class="line">48:                                               ; preds &#x3D; %40, %32</span><br><span class="line">  %49 &#x3D; load i32, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  %50 &#x3D; load i8*, i8** @__afl_area_ptr, !nosanitize !3</span><br><span class="line">  %51 &#x3D; xor i32 %49, 23807</span><br><span class="line">  %52 &#x3D; getelementptr i8, i8* %50, i32 %51</span><br><span class="line">  %53 &#x3D; load i8, i8* %52, !nosanitize !3</span><br><span class="line">  %54 &#x3D; add i8 %53, 1</span><br><span class="line">  store i8 %54, i8* %52, !nosanitize !3</span><br><span class="line">  store i32 11903, i32* @__afl_prev_loc, !nosanitize !3</span><br><span class="line">  call void @exit(i32 0) #3</span><br><span class="line">  unreachable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i64 @&quot;\01_read&quot;(i32, i8*, i64) #1</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noreturn</span><br><span class="line">declare void @exit(i32) #2</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline nounwind ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #2 &#x3D; &#123; noreturn &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #3 &#x3D; &#123; noreturn &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!2&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!2 &#x3D; !&#123;!&quot;clang version 10.0.0 &quot;&#125;</span><br><span class="line">!3 &#x3D; !&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="afl-llvm-rt"><a href="#afl-llvm-rt" class="headerlink" title="afl-llvm-rt"></a>afl-llvm-rt</h3><p>AFL LLVM_Mode中存在着三个特殊的功能。这三个功能的源码位于afl-llvm-rt.o.c中。</p>
<h4 id="deferred-instrumentation"><a href="#deferred-instrumentation" class="headerlink" title="deferred instrumentation"></a>deferred instrumentation</h4><p>AFL会尝试通过仅执行一次目标二进制文件来优化性能。它会暂停控制流，然后复制该“主”进程以持续提供fuzzer的目标。该功能在某些情况下可以减少操作系统、链接与libc内部执行程序的成本。<br>选好位置后，将下述代码添加到该位置上，之后使用afl-clang-fast重新编译代码即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __AFL_HAVE_MANUAL_CONTROL</span><br><span class="line">  __AFL_INIT();</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>__AFL_INIT()</code>内部调用<code>__afl_manual_init</code>函数。该函数的源代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __afl_manual_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">  <span class="keyword">static</span> u8 init_done;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line"></span><br><span class="line">    __afl_map_shm();</span><br><span class="line">    __afl_start_forkserver();</span><br><span class="line">    init_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果还没有被初始化，就初始化共享内存，然后开始执行forkserver，然后设置init_done为1。</p>
<p><code>__afl_map_shm</code>就是简单的通过读取环境变量<code>SHM_ENV_VAR</code>来获取共享内存，然后将地址赋值给<code>__afl_area_ptr</code>。否则，默认的<code>__afl_area_ptr</code>指向的是一个数组。</p>
<p><code>__afl_start_forkserver</code>的逻辑稍微复杂，分条叙述</p>
<ul>
<li>首先设置<code>child_stopped</code>为0，然后通过<code>FORKSRV_FD + 1</code>向状态管道写入4个字节，告知AFL fuzz已经准备好了。</li>
<li>然后进入fuzz loop循环<ul>
<li>通过read从控制管道<code>FORKSRV_FD</code>读取4个字节，如果当前管道中没有内容，就会堵塞在这里，如果读到了，就代表AFL命令我们fork server去执行一次fuzz</li>
<li>如果<code>child_stopped</code>为0，则直接fork出一个子进程去进行fuzz<ul>
<li>然后此时对于子进程就会关闭和控制管道和状态管道相关的fd，然后return跳出fuzz loop，恢复正常执行。</li>
</ul>
</li>
<li>如果<code>child_stopped</code>为1，这是对于persistent mode的特殊处理，此时子进程还活着，只是被暂停了，所以可以通过<code>kill(child_pid, SIGCONT)</code>来简单的重启，然后设置<code>child_stopped</code>为0。</li>
<li>然后fork server向状态管道<code>FORKSRV_FD + 1</code>写入子进程的pid，然后等待子进程结束，注意这里对于persistent mode，我们会设置waitpid的第三个参数为WUNTRACED，代表若子进程进入暂停状态，则马上返回。</li>
<li>WIFSTOPPED(status)宏确定返回值是否对应于一个暂停子进程，因为在persistent mode里子进程会通过SIGSTOP信号来暂停自己，并以此指示运行成功，所以在这种情况下，我们需要再进行一次fuzz，就只需要和上面一样，通过SIGCONT信号来唤醒子进程继续执行即可，不需要再进行一次fuzz。<ul>
<li>设置<code>child_stopped</code>为1。</li>
</ul>
</li>
<li>当子进程结束以后，向状态管道<code>FORKSRV_FD + 1</code>写入4个字节，通知AFL这次target执行结束了。</li>
</ul>
</li>
</ul>
<h4 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h4><p>上面我们其实已经介绍过persistent mode的一些特点了，那就是它并不是通过fork出子进程去进行fuzz的，而是认为当前我们正在fuzz的API是无状态的，当API重置后，一个长期活跃的进程就可以被重复使用，这样可以消除重复执行fork函数以及OS相关所需要的开销。<br>所以的使用方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">  <span class="comment">/* Read input data. */</span></span><br><span class="line">  <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">  <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Exit normally */</span></span><br></pre></td></tr></table></figure>
<p>循环次数不能设置过大，因为较小的循环次数可以将内存泄漏和类似故障的影响降到最低。所以循环次数设置成1000是个不错的选择。</p>
<p>接下来我们来解读一下源码，首先介绍一个<code>__attribute__ constructor</code>，demo如下，代表被此修饰的函数将在main执行之前自动运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor(<span class="number">1</span>))) <span class="function"><span class="keyword">void</span> <span class="title">before_main1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before_main1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((constructor(<span class="number">2</span>))) <span class="function"><span class="keyword">void</span> <span class="title">before_main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before_main2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor(<span class="number">1</span>))) <span class="function"><span class="keyword">void</span> <span class="title">after_main1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after_main1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor(<span class="number">2</span>))) <span class="function"><span class="keyword">void</span> <span class="title">after_main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after_main2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">before_main1</span><br><span class="line">before_main2</span><br><span class="line">main</span><br><span class="line">after_main2</span><br><span class="line">after_main1</span><br></pre></td></tr></table></figure>
<p>llvm mode里有一个函数<code>__attribute__((constructor(CONST_PRIO))) void __afl_auto_init(void)</code>，其逻辑如下</p>
<ul>
<li>读取环境变量PERSIST_ENV_VAR的值，设置给is_persistent</li>
<li>读取环境变量DEFER_ENV_VAR的值，如果为1，就直接返回，这代表<code>__afl_auto_init</code>和deferred instrumentation不通用，这其实道理也很简单，因为deferred instrumentation会自己选择合适的时机，手动init，不需要用这个函数来init，所以这个函数只在没有手动init的时候会自动init。</li>
<li>执行<code>__afl_manual_init</code>函数，其含义见上文。</li>
</ul>
<p>宏定义<code>__AFL_LOOP</code>内部调用<code>__afl_persistent_loop</code>函数。<br><code>__afl_persistent_loop(unsigned int max_cnt)</code>的逻辑如下</p>
<ul>
<li>如果是第一次执行loop<ul>
<li>如果is_persistent为1<ul>
<li>清空<code>__afl_area_ptr</code>，设置<code>__afl_area_ptr[0]</code>为1，<code>__afl_prev_loc</code>为0</li>
</ul>
</li>
<li>设置cycle_cnt的值为传入的max_cnt参数，然后直接返回1</li>
</ul>
</li>
<li>如果不是第一次执行loop<ul>
<li>如果cycle_cnt减一（代表需要执行的循环次数减一）后大于0<ul>
<li>发出信号<code>SIGSTOP</code>来让当前进程暂停</li>
<li>设置<code>__afl_area_ptr[0]</code>为1，<code>__afl_prev_loc</code>为0，然后直接返回1</li>
</ul>
</li>
<li>如果cycle_cnt为0<ul>
<li>设置<code>__afl_area_ptr</code>指向一个无关数组<code>__afl_area_initial</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们将这些联系在一起，重新梳理一遍<br>假设我们是这么使用的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    fuzzAPI();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先在main函数之前读取共享内容，然后以当前进程为fork server，去和AFL fuzz通信。</li>
<li>当AFL fuzz通知进行一次fuzz，由于此时child_stopped为0，则fork server先fork出一个子进程。</li>
<li>这个子进程会很快执行到<code>__AFL_LOOP</code>包围的代码，因为是第一次执行loop，所以会先清空<code>__afl_area_ptr</code>和设置<code>__afl_prev_loc</code>为0，并向共享内存的第一个元素写一个值，然后设置循环次数1000，随后返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI。</li>
<li>然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，此时将循环次数减一，变成999，然后发出信号<code>SIGSTOP</code>来让当前进程暂停，因为我们设置了WUNTRACED，所以waitpid函数就会返回，fork server将继续执行。</li>
<li>fork server在收到<code>SIGSTOP</code>信号后就知道fuzzAPI已经被成功执行结束了，就设置child_stopped为1，并告知AFL fuzz</li>
<li>然后当AFL fuzz通知再进行一次fuzz的时候，fork server将不再需要去fork出一个新的子进程去进行fuzz，只需要恢复之前的子进程继续执行，并设置child_stopped为0</li>
<li>因为我们是<strong>相当于重新执行一次程序</strong>，所以将<code>__afl_prev_loc</code>设置为0，并向共享内存的第一个元素写一个值，随后直接返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成998，并发出信号暂停。</li>
<li>上述过程重复执行，直到第1000次执行时，先恢复执行，然后返回1，然后执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成0，此时循环次数cnt已经被减到0，就不会再发出信号暂停子进程，而是设置<code>__afl_area_ptr</code>指向一个无关数组<code>__afl_area_initial</code>，随后将子进程执行到结束。<ul>
<li><strong>这是因为程序依然会向后执行并触发到instrument，这会向<code>__afl_area_ptr</code>里写值，但是此时我们其实并没有执行<code>fuzzAPI</code>，我们并不想向共享内存里写值，于是将其指向一个无关数组，随意写值。同理，在deferred instrumentation模式里，在执行<code>__afl_manual_init</code>之前，也是向无关数组里写值，因为我们将fork点手动设置，就代表在这个fork点之前的path我们并不关心。</strong></li>
<li>重新整理一下上面的逻辑<ul>
<li>loop第一次执行的时候，会初始化，然后返回1，执行一次fuzzAPI，然后cnt会减到999，然后抛出信号暂停子进程。</li>
<li>loop第二次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到998，然后抛出信号暂停子进程。</li>
<li>loop第1000次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到0，然后就设置指向无关数组，返回0，while循环结束，程序也将执行结束。</li>
</ul>
</li>
</ul>
</li>
<li>此时fork server将不再收到SIGSTOP信号，于是child_stopped仍为0。</li>
<li>所以当AFL fuzz通知fork server再进行一次fuzz的时候，由于此时child_stopped为0，则fork server会先fork出一个子进程，然后后续过程和之前一样了。</li>
<li>有点绕，可以结合代码再读一下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __afl_persistent_loop(<span class="keyword">unsigned</span> <span class="keyword">int</span> max_cnt) &#123;</span><br><span class="line">  <span class="keyword">static</span> u8  first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> u32 cycle_cnt;</span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cycle_cnt  = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123;</span><br><span class="line">      raise(SIGSTOP);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      __afl_area_ptr = __afl_area_initial;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="trace-pc-guard-mode"><a href="#trace-pc-guard-mode" class="headerlink" title="trace-pc-guard mode"></a>trace-pc-guard mode</h4><p>要使用这个功能，需要先通过<code>AFL_TRACE_PC=1</code>来定义DUSE_TRACE_PC宏，从而在执行afl-clang-fast的时候传入<code>-fsanitize-coverage=trace-pc-guard</code>参数，来开启这个功能，和之前我们的插桩不同，开启了这个功能之后，我们不再是仅仅只对每个基本块插桩，而是对每条edge都进行了插桩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifdef AFL_TRACE_PC</span><br><span class="line">  CFLAGS    +&#x3D; -DUSE_TRACE_PC&#x3D;1</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p><code>__sanitizer_cov_trace_pc_guard</code>这个函数将在每个edge调用，该函数利用函数参数guard指针所指向的uint32值来确定共享内存上所对应的地址。<br>每个edge上都有应该有其不同(但其实可能相同，原因下述)的guard值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个guard指针的初始化在<code>__sanitizer_cov_trace_pc_guard_init</code>函数里，llvm会设置guard其首末分别为start和stop。<br>它会从第一个guard开始向后遍历，设置guard指向的值，这个值是通过<code>R(MAP_SIZE)</code>设置的，定义如下，所以如果我们的edge足够多，而<code>MAP_SIZE</code>不够大，就有可能重复，而这个加一是因为我们会把0当成一个特殊的值，其代表对这个edge不进行插桩。<br>这个init其实很有趣，我们可以打印输出一下<code>stop-start</code>的值，就代表了llvm发现的程序里总计的edge数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> R(x) (random() % (x))</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">  *(start++) = R(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; <span class="built_in">stop</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (R(<span class="number">100</span>) &lt; inst_ratio) *start = R(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> *start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    start++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="afl-fuzz长叙"><a href="#afl-fuzz长叙" class="headerlink" title="afl-fuzz长叙"></a>afl-fuzz长叙</h2><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h4><p>注册必要的信号处理函数</p>
<ul>
<li><a href="https://www.cnblogs.com/52php/p/5813867.html" target="_blank" rel="noopener">Linux进程间通信（一）：信号 signal()、sigaction()</a></li>
<li>SIGHUP/SIGINT/SIGTERM<ul>
<li>hangup/interrupt/software termination signal from kill</li>
<li>主要是”stop”的处理函数</li>
<li>handle_stop_sig<ul>
<li>设置stop_soon为1</li>
<li>如果child_pid存在，向其发送SIGKILL终止信号，从而被系统杀死。</li>
<li>如果forksrv_pid存在，向其发送SIGKILL终止信号</li>
</ul>
</li>
</ul>
</li>
<li>SIGALRM<ul>
<li>alarm clock</li>
<li>处理超时的情况</li>
<li>handle_timeout<ul>
<li>如果child_pid&gt;0，则设置child_timed_out为1，并kill掉child_pid</li>
<li>如果child_pid==-1，且forksrv_pid&gt;0，则设置child_timed_out为1，并kill掉forksrv_pid</li>
</ul>
</li>
</ul>
</li>
<li>SIGWINCH<ul>
<li>Window resize</li>
<li>处理窗口大小的变化信号</li>
<li>handle_resize<ul>
<li>设置clear_screen=1</li>
</ul>
</li>
</ul>
</li>
<li>SIGUSR1<ul>
<li>user defined signal 1，这个是留给用户自定义的信号</li>
<li>这里定义成skip request (SIGUSR1)</li>
<li>handle_skipreq<ul>
<li>设置skip_requested=1</li>
</ul>
</li>
</ul>
</li>
<li>SIGTSTP/SIGPIPE<ul>
<li>stop signal from tty/write on a pipe with no one to read it</li>
<li>不关心的一些信号</li>
<li>SIG_IGN</li>
</ul>
</li>
</ul>
<h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><p>check asan选项</p>
<ul>
<li>读取环境变量ASAN_OPTIONS和MSAN_OPTIONS，做一些检查</li>
</ul>
<h4 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h4><p>如果通过-M或者-S指定了sync_id，则更新out_dir和sync_dir的值</p>
<ul>
<li>设置sync_dir的值为out_dir</li>
<li>设置out_dir的值为<code>out_dir/sync_id</code></li>
</ul>
<h4 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h4><p>拷贝当前的命令行参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 ff 00 ff   55 00 00 00   buf-&gt; 2f 55 73 65   72 73 2f 73   │ ····U···&#x2F;Users&#x2F;s │</span><br><span class="line">61 6b 75 72   61 2f 67 69   74 73 6f 75   72 63 65 2f   │ akura&#x2F;gitsource&#x2F; │</span><br><span class="line">41 46 4c 2f   63 6d 61 6b   65 2d 62 75   69 6c 64 2d   │ AFL&#x2F;cmake-build- │</span><br><span class="line">64 65 62 75   67 2f 61 66   6c 2d 66 75   7a 7a 20 2d   │ debug&#x2F;afl-fuzz - │</span><br><span class="line">69 20 69 6e   70 75 74 20   2d 6f 20 6f   75 74 70 75   │ i input -o outpu │</span><br><span class="line">74 20 2d 2d   20 2e 2f 74   65 73 74 00   00 f0 00 00   │ t -- .&#x2F;test·····</span><br></pre></td></tr></table></figure>
<h4 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h4><p>修剪并且创建一个运行横幅</p>
<h4 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h4><p>检查是否在tty终端上面运行。</p>
<ul>
<li>读取环境变量AFL_NO_UI的值，如果为真，则设置not_on_tty为1，并返回</li>
<li><code>ioctl(1, TIOCGWINSZ, &amp;ws)</code>通过ioctl来读取window size，如果报错为ENOTTY，则代表当前不在一个tty终端运行，设置not_on_tty</li>
</ul>
<h4 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h4><p>计数logical CPU cores</p>
<h4 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h4><h4 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h4><h4 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h4><h4 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h4><p>配置共享内存和virgin_bits</p>
<ul>
<li><a href="https://www.cnblogs.com/52php/p/5861372.html" target="_blank" rel="noopener">Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl()</a></li>
<li>如果in_bitmap为空，则通过memset初始化数组virgin_bits[MAP_SIZE]的每个元素的值为’255’(\xff)</li>
<li>通过memset设置virgin_tmout[MAP_SIZE]和virgin_crash[MAP_SIZE]的每个元素的值为’255’(\xff)</li>
<li>调用shmget分配一块共享内存，<code>shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);</code>,将返回的共享内存标识符保存到shm_id里。<ul>
<li><code>int shmget(key_t key, size_t size, int shmflg);</code></li>
<li>第一个参数，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.<ul>
<li>这里shm_id取值是IPC_PRIVATE，所以函数shmget()将创建一块新的共享内存</li>
</ul>
</li>
<li>第二个参数，size以字节为单位指定需要共享的内存容量<ul>
<li>这里取值为MAP_SIZE</li>
</ul>
</li>
<li>第三个参数，shmflg是权限标志<ul>
<li>IPC_CREAT   如果共享内存不存在，则创建一个共享内存，否则打开操作。</li>
<li>IPC_EXCL     只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。</li>
<li>421分别表示，读写执行3种权限。 比如，上面的6＝4＋2，表示读＋写。 </li>
<li>0600 每一位表示一种类型的权限，比如，第一位是表示八进制,第二位表示拥有者的权限为读写，第三位表示同组无权限，第四位表示他人无权限。</li>
</ul>
</li>
</ul>
</li>
<li>注册atexit handler为remove_shm<ul>
<li>remove_shm<ul>
<li>shmctl(shm_id, IPC_RMID, NULL);<ul>
<li>第一个参数，shm_id是shmget()函数返回的共享内存标识符。</li>
<li>第二个参数，command是要采取的操作，它可以取下面的三个值<ul>
<li>IPC_RMID：删除共享内存段</li>
</ul>
</li>
<li>第三个参数，buf是一个结构指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用alloc_printf(“%d”, shm_id)来创建一个字符串shm_str<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 ff 00 ff   06 00 00 00  shm_str-&gt;36 35 35 33   38 00 f0 f0   │ ········65538··· │</span><br></pre></td></tr></table></figure></li>
<li>如果不是dumb_mode，<strong>则设置环境变量SHM_ENV_VAR的值为shm_str</strong></li>
<li><code>trace_bits = shmat(shm_id, NULL, 0);</code><ul>
<li>trace_bits是用做<code>SHM with instrumentation bitmap</code></li>
<li>第一次创建完共享内存时，它还不能被任何进程访问，所以通过shmat来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</li>
<li><code>void *shmat(int shm_id, const void *shm_addr, int shmflg)</code><ul>
<li>第一个参数，shm_id是由shmget()函数返回的共享内存标识。</li>
<li>第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</li>
<li>第三个参数，shm_flg是一组标志位，通常为0。</li>
<li>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.<h4 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h4>这其实是因为trace_bits是用一个字节来记录是否到达这个路径，和这个路径被命中了多少次的，而这个次数在0-255之间，但比如一个循环，它循环5次和循环6次可能是完全一样的效果，为了避免被当成不同的路径，或者说尽可能减少因为命中次数导致的区别。<br>在每次去计算是否发现了新路径之前，先把这个路径命中数进行规整，比如把命中5次和6次都统一认为是命中了8次，见下面这个。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line">        [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">        [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">        [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">        [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">        [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">        [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">        [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">        [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">        [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
而为什么又需要用一个<code>count_class_lookup16</code>呢，是因为AFL在后面实际进行规整的时候，是一次读两个字节去处理的，为了提高效率，这只是出于效率的考量，实际效果还是上面这种效果。<br>初始化<code>u16 count_class_lookup16[65536]</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    u32 b1, b2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++)</span><br><span class="line">        <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">            count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] =</span><br><span class="line">                    (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">                    count_class_lookup8[b2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h4><p>准备输出文件夹和fd</p>
<ul>
<li>如果sync_id存在，且创建sync_dir文件夹，设置权限为0700（读写执行）<ul>
<li>如果报错，且errno不是EEXIST，则抛出异常。</li>
</ul>
</li>
<li>创建out_dir，设置权限为0700（读写执行）<ul>
<li>如果报错，且errno不是EEXIST，则抛出异常。<ul>
<li>maybe_delete_out_dir</li>
</ul>
</li>
<li>如果创建成功<ul>
<li>如果设置了in_place_resume，就抛出异常”Resume attempted but old output directory not found”</li>
<li><code>out_dir_fd = open(out_dir, O_RDONLY)</code>以只读模式打开这个文件，并返回文件句柄out_dir_fd</li>
<li>如果没有定义宏<code>__sun</code><ul>
<li>如果打开out_dir失败，或者为out_dir通过flock建立互斥锁定失败，就抛出异常”Unable to flock() output directory.”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>建立queue文件夹<ul>
<li>创建<code>out_dir/queue</code>文件夹，设置权限为0700<ul>
<li>创建<code>out_dir/queue/.state/</code>,设置权限为0700,该文件夹主要<strong>保存用于session resume和related tasks的queue metadata</strong><ul>
<li>创建<code>out_dir/queue/.state/deterministic_done/</code>,设置权限为0700,该文件夹<strong>标记过去经历过deterministic fuzzing的queue entries</strong>。</li>
<li>创建<code>out_dir/queue/.state/auto_extras/</code>,设置权限为0700,<strong>Directory with the auto-selected dictionary entries.</strong></li>
<li>创建<code>out_dir/queue/.state/redundant_edges/</code>,设置权限为0700,<strong>保存当前被认为是多余的路径集合</strong></li>
<li>创建<code>out_dir/queue/.state/variable_behavior/</code>,设置权限为0700,<strong>The set of paths showing variable behavior.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果sync_id存在<ul>
<li>创建<code>out_dir/.synced/</code>,设置权限为0700,<strong>同步文件夹，用于跟踪cooperating fuzzers.</strong></li>
</ul>
</li>
<li>建立crashes文件夹<ul>
<li>创建<code>out_dir/crashes</code>文件夹，设置权限为0700,用于记录crashes</li>
</ul>
</li>
<li>建立hangs文件夹<ul>
<li>创建<code>out_dir/hangs</code>文件夹，设置权限为0700,用于记录hangs</li>
</ul>
</li>
<li>通常有用的文件描述符<ul>
<li><code>dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</code>以读写模式打开<code>/dev/null</code></li>
<li><code>dev_urandom_fd = open(&quot;/dev/urandom&quot;, O_RDONLY);</code>,以只读模式打开<code>/dev/urandom</code></li>
</ul>
</li>
<li>建立Gnuplot输出文件夹<ul>
<li><code>fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, 0600);</code>以只写方式打开<code>out_dir/plot_data</code>文件，如果文件不存在，就创建，并获取句柄</li>
<li><code>plot_file = fdopen(fd, &quot;w&quot;);</code>根据句柄得到FILE* plot_file</li>
<li>向其中写入<code># unix_time, cycles_done, cur_path, paths_total, pending_total, pending_favs, map_size, unique_crashes, unique_hangs, max_depth, execs_per_sec\n</code></li>
</ul>
</li>
</ul>
<h4 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h4><p>从输入文件夹中读取所有文件，然后将它们排队进行测试。</p>
<ul>
<li>尝试访问<code>in_dir/queue</code>文件夹，如果存在就重新设置in_dir为<code>in_dir/queue</code><ul>
<li>Auto-detect non-in-place resumption attempts.</li>
</ul>
</li>
<li>扫描in_dir，并将结果保存在<code>struct dirent **nl</code>里<ul>
<li>不使用readdir,因为测试用例的顺序将随机地有些变化,并且将难以控制。</li>
</ul>
</li>
<li>遍历nl,nl[i]-&gt;d_name的值为input文件夹下的文件名字符串<ul>
<li><code>u8 *fn = alloc_printf(&quot;%s/%s&quot;, in_dir, nl[i]-&gt;d_name);</code></li>
<li><code>u8 *dfn = alloc_printf(&quot;%s/.state/deterministic_done/%s&quot;, in_dir, nl[i]-&gt;d_name);</code></li>
<li>如果<code>shuffle_queue</code>的值为真，且nl_cnt大于1，则<code>shuffle_ptrs((void **) nl, nl_cnt)</code>，字面意思上就是重排nl里的指针的位置。</li>
<li>通过文件属性过滤掉<code>.</code>和<code>..</code>这样的regular文件，并检查文件大小，如果文件大小大于MAX_FILE，默认是1024*1024字节，即1M</li>
<li>通过access检查<code>in_dir/.state/deterministic_done/nl[i]-&gt;d_name</code>是否存在，这应该是为了用在resume恢复扫描使用<ul>
<li>如果存在就设置passed_det为1</li>
<li>这个检查是用来判断是否这个entry已完成deterministic fuzzing。在恢复异常终止的扫描时，我们不想重复deterministic fuzzing，因为这将毫无意义，而且可能非常耗时</li>
</ul>
</li>
<li>add_to_queue(fn, st.st_size, passed_det);</li>
<li>如果queued_paths为0，则代表输入文件夹为0，抛出异常</li>
<li>设置last_path_time为0</li>
<li>queued_at_start的值设置为queued_paths<ul>
<li>Total number of initial inputs</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="add-to-queue-u8-fname-u32-len-u8-passed-det"><a href="#add-to-queue-u8-fname-u32-len-u8-passed-det" class="headerlink" title="add_to_queue(u8 *fname, u32 len, u8 passed_det)"></a>add_to_queue(u8 *fname, u32 len, u8 passed_det)</h4><ul>
<li>queue_entry是一个链表数据结构</li>
<li>先通过calloc动态分配一个queue_entry结构体，并<strong>初始化其fname为文件名fn，len为文件大小，depth为cur_depth + 1,passed_det为传递进来的passed_det</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;fname = fname;</span><br><span class="line">q-&gt;len = len;</span><br><span class="line">q-&gt;depth = cur_depth + <span class="number">1</span>;</span><br><span class="line">q-&gt;passed_det = passed_det;</span><br></pre></td></tr></table></figure></li>
<li>如果<code>q-&gt;depth &gt; max_depth</code>，则设置max_depth为q-&gt;depth</li>
<li>如果queue_top不为空，则设置<code>queue_top-&gt;next为q，queue_top = q;</code>，否则<code>q_prev100 = queue = queue_top = q;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue</span>,     /* <span class="title">Fuzzing</span> <span class="title">queue</span> (<span class="title">linked</span> <span class="title">list</span>)      */</span></span><br><span class="line"><span class="class">*<span class="title">queue_top</span>, /* <span class="title">Top</span> <span class="title">of</span> <span class="title">the</span> <span class="title">list</span>                  */</span></span><br><span class="line"><span class="class">*<span class="title">q_prev100</span>;</span> <span class="comment">/* Previous 100 marker              */</span></span><br></pre></td></tr></table></figure></li>
<li>queue计数器queued_paths和待fuzz的样例计数器pending_not_fuzzed加一</li>
<li>cycles_wo_finds设置为0<ul>
<li>Cycles without any new paths</li>
</ul>
</li>
<li>如果<code>queued_paths % 100</code>得到0，则设置<code>q_prev100-&gt;next_100 = q; q_prev100 = q;</code></li>
<li>设置last_path_time为当前时间。</li>
</ul>
<h4 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h4><p>load自动生成的提取出来的词典token</p>
<ul>
<li>遍历循环从i等于0到USE_AUTO_EXTRAS，默认50<ul>
<li>以只读模式尝试打开文件名为<code>alloc_printf(&quot;%s/.state/auto_extras/auto_%06u&quot;, in_dir, i)</code>的文件</li>
<li>如果打开失败，则结束</li>
<li>如果打开成功，则从fd读取最多<code>MAX_AUTO_EXTRA+1</code>个字节到tmp数组里，默认MAX_AUTO_EXTRA为32，这是单个auto extra文件的最大大小，读取出的长度保存到len里。</li>
<li>maybe_add_auto(tmp, len);<br>};</li>
</ul>
</li>
</ul>
<h4 id="maybe-add-auto-u8-mem-u32-len"><a href="#maybe-add-auto-u8-mem-u32-len" class="headerlink" title="maybe_add_auto(u8 *mem, u32 len)"></a>maybe_add_auto(u8 *mem, u32 len)</h4><ul>
<li>如果用户设置了MAX_AUTO_EXTRAS或者USE_AUTO_EXTRAS为0，则直接返回。</li>
<li>循环遍历i从1到len，将tmp[0]和mem[i]异或，如果相同，则结束循环。</li>
<li>如果结束时i=0，即tmp[0]和tmp[1]就相同，就直接返回。这里我推断tmp应该是从小到大排序的字节流。</li>
<li>如果len的长度为2，就和interesting_16数组里的元素比较，如果和其中某一个相同，就直接return。</li>
<li>如果len的长度为4，就和interesting_32数组里的元素比较，如果和其中某一个相同，就直接return。</li>
<li>将tmp和现有的extras数组里的元素比较，利用extras数组里保存的元素是按照size大小，从小到大排序这个特性，来优化代码。<ul>
<li>遍历extras数组，比较<code>memcmp_nocase(extras[i].data, mem, len)</code>,如果有一个相同，就直接return。</li>
<li>static struct extra_data <em>extras;     /</em> Extra tokens to fuzz with        */</li>
</ul>
</li>
<li>设置auto_changed为1</li>
<li>遍历a_extras数组，比较<code>memcmp_nocase(a_extras[i].data, mem, len)</code>,如果相同，就将其hit_cnt值加一，这是代表在语料中被use的次数,然后跳转到<code>sort_a_extras</code><ul>
<li>static struct extra_data <em>a_extras;   /</em> Automatically selected extras    */<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extra_data</span> &#123;</span></span><br><span class="line">u8 *data;                           <span class="comment">/* Dictionary token data            */</span></span><br><span class="line">u32 len;                            <span class="comment">/* Dictionary token length          */</span></span><br><span class="line">u32 hit_cnt;                        <span class="comment">/* Use count in the corpus          */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>此时我们可能在处理一个不在之前的任何a_extras或者extras数组里的新entry了，处理逻辑是<ul>
<li>先比较a_extras_cnt和MAX_AUTO_EXTRAS，如果小于就代表a_extras数组没有填满，直接拷贝tmp和len，来构造出一个新项，加入到a_extras数组里</li>
<li>否则的话，就从a_extras数组的后半部分里，随机替换掉一个元素的a_extras[i].data为ck_memdup(mem, len)，并将len设置为len，hit_cnt设置为0。</li>
</ul>
</li>
</ul>
<h4 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h4><p>逻辑上说这个函数就是为inputdir里的testcase，在output dir里创建hard link</p>
<ul>
<li>初始化id=0</li>
<li>依次遍历queue里的queue_entry<ul>
<li>在q-&gt;fname里找到最后一个’/‘所在的位置，如果找不到，则<code>rsl = q-&gt;fname</code>,否则rsl指向’/‘后的第一个字符,其实也就是最后一个<code>/</code>后面的字符串</li>
<li>将rsl的前三个字节和<code>id_</code>进行比较<ul>
<li>如果相等，则设置<code>resuming_fuzz</code>为1,然后做一些恢复操作，不叙述。</li>
<li>如果不相等<ul>
<li>在rsl里寻找<code>,orig:</code>子串，如果找到了，将use_name指向该子串的冒号后的名字；如果没找到，就另<code>use_name = rsl</code></li>
<li><code>nfn = alloc_printf(&quot;%s/queue/id:%06u,orig:%s&quot;, out_dir, id, use_name);</code></li>
<li>尝试创建从input file到<code>alloc_printf(&quot;%s/queue/id:%06u,orig:%s&quot;, out_dir, id, use_name)</code>的硬链接</li>
</ul>
</li>
</ul>
</li>
<li>修改q的fname指向这个硬链接</li>
<li>如果q的passed_det为1，则mark_as_det_done(q),这主要是对应上面的resuming_fuzz的情况。<ul>
<li>mark_as_det_done简单的说就是打开<code>out_dir/queue/.state/deterministic_done/use_name</code>这个文件，如果不存在就创建这个文件，然后设置q的passed_det为1。</li>
<li>这里的<code>use_name就是orig:后面的字符串</code></li>
</ul>
</li>
</ul>
</li>
<li>如果设置了in_place_resume为1，则nuke_resume_dir()<ul>
<li>nuke_resume_dir()<ul>
<li>删除<code>out_dir/_resume/.state/deterministic_done</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/auto_extras</code>文件夹下所有<code>auto_</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/redundant_edges</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/variable_behavior</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除文件夹<code>out_dir/_resume/.state</code></li>
<li>删除<code>out_dir/_resume</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>如果全部删除成功就正常返回，如果有某一个删除失败就抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h4><p>如果定义了extras_dir，则从extras_dir读取extras到extras数组里，并按size排序。</p>
<h4 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h4><p>如果timeout_given没有被设置，则进入find_timeout<br>这个想法是，在不指定-t的情况下resuming sessions时，我们不希望一遍又一遍地自动调整超时时间，以防止超时值因随机波动而增长</p>
<ul>
<li>如果resuming_fuzz为0，则直接return</li>
<li>如果in_place_resume为1，则<code>fn = alloc_printf(&quot;%s/fuzzer_stats&quot;, out_dir);</code>，否则<code>fn = alloc_printf(&quot;%s/../fuzzer_stats&quot;, in_dir);</code></li>
<li>以只读方式打开fd，读取内容到tmp[4096]里，并在里面搜索”exec_timeout      : “，如果搜索不到就直接返回，如果搜索到了，就读取这个timeout的数值，如果大于4就设置为exec_tmout的值。<ul>
<li>EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */</li>
</ul>
</li>
<li>timeout_given = 3;<ul>
<li>timeout_given,             /* Specific timeout given?          */</li>
</ul>
</li>
</ul>
<h4 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h4><p>这个函数其实就是识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</p>
<h4 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h4><p>如果out_file为NULL，如果没有使用-f，就删除原本的<code>out_dir/.cur_input</code>，创建一个新的<code>out_dir/.cur_input</code>，保存其文件描述符在out_fd中</p>
<h4 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h4><p>check指定路径处要执行的程序是否存在，且它不能是一个shell script</p>
<h4 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h4><p>执行所有的测试用例，以检查是否按预期工作</p>
<ul>
<li>读取环境变量AFL_SKIP_CRASHES到skip_crashes，设置cal_failures为0</li>
<li>遍历queue<ul>
<li>打开q-&gt;fname，并读取到分配的内存use_mem里</li>
<li>res = calibrate_case(argv, q, use_mem, 0, 1);<ul>
<li>校准测试用例，见下文</li>
</ul>
</li>
<li>如果stop_soon被置为1，就直接return</li>
<li>如果res的结果为crash_mode或者FAULT_NOBITS<ul>
<li>打印<code>SAYF(&quot;len = %u, map size = %u, exec speed = %llu us\n&quot;, q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</code></li>
</ul>
</li>
<li>依据res的结果查看是哪种错误并进行判断。一共有以下几种错误类型<ul>
<li>FAULT_NONE<ul>
<li>如果q是头结点，即第一个测试用例，则<code>check_map_coverage</code>，用以评估map coverage<ul>
<li>计数trace_bits发现的路径数，如果小于100，就直接返回</li>
<li>在trace_bits的数组后半段，如果有值就直接返回。</li>
<li>抛出警告<code>WARNF(&quot;Recompile binary with newer version of afl to improve coverage!&quot;)</code></li>
</ul>
</li>
<li>如果是crash_mode，则抛出异常，<code>FATAL(&quot;Test case &#39;%s&#39; does *NOT* crash&quot;, fn);</code>，该文件不崩溃</li>
</ul>
</li>
<li>FAULT_TMOUT<ul>
<li>如果指定了-t参数，则timeout_given值为2<ul>
<li>抛出警告<code>WARNF(&quot;Test case results in a timeout (skipping)&quot;);</code>，并设置q的cal_failed为CAL_CHANCES，cal_failures计数器加一。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>如果没有指定mem_limit，则可能抛出建议增加内存的建议</li>
<li>但不管指定了还是没有，都会抛出异常<code>FATAL(&quot;Test case &#39;%s&#39; results in a crash&quot;, fn);</code></li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常<code>Unable to execute target application</code></li>
</ul>
</li>
<li>FAULT_NOINST<ul>
<li>这个样例运行没有出现任何路径信息，抛出异常<code>No instrumentation detected</code></li>
</ul>
</li>
<li>FAULT_NOBITS<ul>
<li>如果这个样例有出现路径信息，但是没有任何新路径，抛出警告<code>WARNF(&quot;No new instrumentation output, test case may be useless.&quot;)</code>，认为这是无用路径。useless_at_start计数器加一</li>
</ul>
</li>
</ul>
</li>
<li>如果这个样例q的var_behavior为真，则代表它多次运行，同样的输入条件下，却出现不同的覆盖信息。<ul>
<li>抛出警告<code>WARNF(&quot;Instrumentation output varies across runs.&quot;);</code>，代表这个样例的路径输出可变</li>
</ul>
</li>
<li>然后读取下一个queue，继续测试，直到结束。     <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line"><span class="comment">/* 00 */</span> FAULT_NONE,</span><br><span class="line"><span class="comment">/* 01 */</span> FAULT_TMOUT,</span><br><span class="line"><span class="comment">/* 02 */</span> FAULT_CRASH,</span><br><span class="line"><span class="comment">/* 03 */</span> FAULT_ERROR,</span><br><span class="line"><span class="comment">/* 04 */</span> FAULT_NOINST,</span><br><span class="line"><span class="comment">/* 05 */</span> FAULT_NOBITS &#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue"><a href="#u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue" class="headerlink" title="u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)"></a>u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)</h4><p>这个函数评估input文件夹下的case，来发现这些testcase的行为是否异常；以及在发现新的路径时，用以评估这个新发现的testcase的行为是否是可变（这里的可变是指多次执行这个case，发现的路径不同）等等</p>
<ul>
<li>这个函数的参数为<code>char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue</code></li>
<li>创建first_trace[MAP_SIZE]</li>
<li>如果q-&gt;exec_cksum为0，代表这是这个case第一次运行，即来自input文件夹下，所以将first_run置为1。</li>
<li>保存原有的stage_cur、stage_max、stage_name</li>
<li>设置use_tmout为exec_tmout,如果from_queue是0或者resuming_fuzz被置为1，即代表不来自于queue中或者在resuming sessions的时候，则use_tmout的值被设置的更大。</li>
<li>q-&gt;cal_failed++</li>
<li>设置stage_name为”calibration”,以及根据是否fast_cal为1，来设置stage_max的值为3还是CAL_CYCLES(默认为8)，含义是每个新测试用例（以及显示出可变行为的测试用例）的校准周期数，也就是说这个stage要执行几次的意思。</li>
<li>如果当前不是以dumb mode运行，且no_forkserver（禁用forkserver）为0，且forksrv_pid为0，则init_forkserver(argv)启动fork server，见后文。</li>
<li>如果<strong>这个queue不是来自input文件夹，而是评估新case</strong>，则此时<code>q-&gt;exec_cksum</code>不为空，拷贝trace_bits到first_trace里，然后计算<code>has_new_bits</code>的值，赋值给new_bits。</li>
<li>开始执行calibration stage，共执行stage_max轮<ul>
<li>如果<strong>这个queue不是来自input文件夹，而是评估新case</strong>，且第一轮calibration stage执行结束时，刷新一次展示界面<code>show_stats</code>，用来展示这次执行的结果，此后不再展示。</li>
<li>write_to_testcase(use_mem, q-&gt;len)<ul>
<li>将从<code>q-&gt;fname</code>中读取的内容写入到<code>.cur_input</code>中</li>
</ul>
</li>
<li><code>u8 run_target(argv, use_tmout)</code>,结果保存在fault中</li>
<li>如果这是<code>calibration stage</code>第一次运行，且不在dumb_mode，且共享内存里没有任何路径（即没有任何byte被置位），设置fault为<code>FAULT_NOINST</code>,然后goto abort_calibration。<ul>
<li>计算共享内存里有多少字节被置位了,通过count_bytes函数<ul>
<li><code>u32 count_bytes(u8 *mem)</code></li>
</ul>
</li>
</ul>
</li>
<li>计算<code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>的结果，其值为一个32位uint值，保存到cksum中</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于cksum，即代表<strong>这是第一次运行，或者在相同的参数下，每次执行，cksum却不同，是一个路径可变的queue</strong><ul>
<li><code>hnb = has_new_bits(virgin_bits)</code></li>
<li>如果hnb大于new_bits，设置new_bits的值为hnb</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于0，即代表这是判断是否是可变queue<ul>
<li>i从0到MAP_SIZE遍历，如果first_trace[i]不等于trace_bits[i]，<strong>代表发现了可变queue</strong>，且var_bytes为空，则将该字节设置为1，并将stage_max设置为<code>CAL_CYCLES_LONG</code>，即需要执行40次。</li>
<li>将var_detected设置为1</li>
</ul>
</li>
<li>否则，即q-&gt;exec_cksum等于0，即代表这是第一次执行这个queue<ul>
<li>设置q-&gt;exec_cksum的值为之前计算出来的本次执行的cksum</li>
<li>拷贝trace_bits到first_trace中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>保存所有轮次总的执行时间，加到total_cal_us里，总的执行轮次，加到total_cal_cycles里</li>
<li>计算出一些统计信息，包括<ul>
<li>计算出单次执行时间的平均值保存到q-&gt;exec_us里</li>
<li>将最后一次执行所覆盖到的路径数保存到q-&gt;bitmap_size里</li>
<li><code>q-&gt;handicap = handicap;</code></li>
<li><code>q-&gt;cal_failed = 0;</code></li>
<li>total_bitmap_size里加上这个queue所覆盖到的路径数</li>
<li>total_bitmap_entries++</li>
<li>update_bitmap_score(struct queue_entry *q)</li>
</ul>
</li>
<li>如果fault为<code>FAULT_NONE</code>，且该queue是第一次执行，且不属于dumb_mode，而且new_bits为0，代表在这个样例所有轮次的执行里，都没有发现任何新路径和出现异常，设置fault为<code>FAULT_NOBITS</code></li>
<li>如果new_bits为2，且<code>q-&gt;has_new_cov</code>为0，设置其值为1，并将queued_with_cov加一，代表有一个queue发现了新路径。</li>
<li>如果这个queue是可变路径，即var_detected为1，则计算var_bytes里被置位的tuple个数，保存到var_byte_count里，代表这些tuple具有可变的行为。</li>
<li>将这个queue标记为一个variable<ul>
<li><code>mark_as_variable(struct queue_entry *q)</code><ul>
<li>创建符号链接<code>out_dir/queue/.state/variable_behavior/fname</code></li>
<li>设置queue的var_behavior为1</li>
</ul>
</li>
<li>计数variable behavior的计数器<code>queued_variable</code>的值加一</li>
</ul>
</li>
<li>恢复之前的stage值</li>
<li>如果不是第一次运行这个queue，展示<code>show_stats</code></li>
<li>返回fault的值</li>
</ul>
<h4 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h4><ul>
<li><p>建立管道st_pipe和ctl_pipe，在父子进程之间，是通过管道进行通信，一个用于传递状态，另一个用于传递命令。</p>
<ul>
<li>在继续往下读之前需要仔细阅读这篇文章</li>
<li><a href="https://zhuanlan.zhihu.com/p/58489873" target="_blank" rel="noopener">Linux 的进程间通信：管道</a><br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg" alt=""></li>
</ul>
</li>
<li><p>fork出一个子进程，fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>
<ul>
<li>forksrv_pid = fork()</li>
</ul>
</li>
<li><p>子进程和父进程都会向下执行，我们通过pid来使它们执行不同的代码<code>if(!forksrv_pid)</code></p>
<ul>
<li>以下都是子进程要执行的代码<ul>
<li>在继续向下读之前，需要仔细阅读这篇文章<ul>
<li><a href="https://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html" target="_blank" rel="noopener">进程间通信管道进阶篇：linux下dup/dup2函数的用法</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">假设进程A拥有一个已打开的文件描述符fd3，它的状态如下</span><br><span class="line">进程A的文件描述符表(before dup2)</span><br><span class="line">------------</span><br><span class="line">fd0 <span class="number">0</span>   | p0</span><br><span class="line">------------</span><br><span class="line">fd1 <span class="number">1</span>   | p1 -------------&gt; 文件表<span class="number">1</span> ---------&gt; vnode1</span><br><span class="line">------------</span><br><span class="line">fd2 <span class="number">2</span>   | p2</span><br><span class="line">------------</span><br><span class="line">fd3 <span class="number">3</span>   | p3 -------------&gt; 文件表<span class="number">2</span> ---------&gt; vnode2</span><br><span class="line">------------</span><br><span class="line">... ...</span><br><span class="line">... ...</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">经下面调用：</span><br><span class="line">n_fd = dup2(fd3, STDOUT_FILENO);后进程状态如下：</span><br><span class="line"></span><br><span class="line">进程A的文件描述符表(after dup2)</span><br><span class="line">------------</span><br><span class="line">fd0 <span class="number">0</span>   | p0</span><br><span class="line">------------</span><br><span class="line">n_fd <span class="number">1</span>  | p1 ------------</span><br><span class="line">------------               \</span><br><span class="line">fd2 <span class="number">2</span>   | p2                  \</span><br><span class="line">------------                 _\|</span><br><span class="line">fd3 <span class="number">3</span>   | p3 -------------&gt; 文件表<span class="number">2</span> ---------&gt; vnode2</span><br><span class="line"></span><br><span class="line">在学习dup2时总是碰到“重定向”一词，上图完成的就是一个“从标准输出到文件的重定向”，经过dup2后进程A的任何目标为STDOUT_FILENO的I/O操作如<span class="built_in">printf</span>等，其数据都将流入fd3所对应的文件中。下面是一个例子程序：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTSTR <span class="meta-string">"Hello dup2\n"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     fd3;</span><br><span class="line"></span><br><span class="line">        fd3 = <span class="built_in">open</span>(<span class="string">"testdup2.dat"</span>, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open error\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dup2(fd3, STDOUT_FILENO) &lt; <span class="number">0</span>) &#123;       </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"err in dup2\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(TESTSTR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其结果就是你在testdup2.dat中看到<span class="string">"Hello dup2"</span>。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>重定向文件描述符1和2到dev_null_fd，如果指定了out_file，则文件描述符0重定向到dev_null_fd，否则重定向到out_fd。<ul>
<li><code>dup2(dev_null_fd, 1);</code></li>
<li><code>dup2(dev_null_fd, 2);</code></li>
</ul>
</li>
<li>重定向FORKSRV_FD到ctl_pipe[0],重定向FORKSRV_FD + 1到st_pipe[1]<ul>
<li>子进程只能读取命令</li>
<li>子进程只能发送(“写出”)状态</li>
</ul>
</li>
<li>关闭子进程里的一些文件描述符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(out_dir_fd);</span><br><span class="line"><span class="built_in">close</span>(dev_null_fd);</span><br><span class="line"><span class="built_in">close</span>(dev_urandom_fd);</span><br><span class="line"><span class="built_in">close</span>(fileno(plot_file));</span><br></pre></td></tr></table></figure></li>
<li>读取环境变量LD_BIND_LAZY，如果没有设置，则设置环境变量LD_BIND_NOW为1</li>
<li>设置环境变量ASAN_OPTIONS为<code>&quot;abort_on_error=1:&quot; &quot;detect_leaks=0:&quot; &quot;symbolize=0:&quot; &quot;allocator_may_return_null=1&quot;</code>，同理设置MSAN_OPTIONS</li>
<li><code>execv(target_path, argv)</code>带参数执行target,这个函数除非出错不然不会返回。<ul>
<li>execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</li>
<li><strong>而在这里非常特殊，第一个target会进入<code>__afl_maybe_log</code>里的<code>__afl_fork_wait_loop</code>，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。</strong></li>
</ul>
</li>
<li>使用一个独特的bitmaps EXEC_FAIL_SIG(0xfee1dead)写入trace_bits，来告诉父进程执行失败，并结束子进程。</li>
</ul>
</li>
</ul>
</li>
<li><p>以下都是父进程要执行的代码</p>
<ul>
<li>关闭不需要的endpoints  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭不是需要的endpoints</span></span><br><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];<span class="comment">//父进程只能发送("写出")命令</span></span><br><span class="line">fsrv_st_fd = st_pipe[<span class="number">0</span>];<span class="comment">//父进程只能读取状态</span></span><br></pre></td></tr></table></figure></li>
<li>等待fork server启动，但是不能等太久。（所以在调试时要注意这个…）<ul>
<li>从管道里读取4个字节到status里，如果读取成功，则代表fork server成功启动，就结束这个函数并返回。</li>
<li>如果超时，就抛出异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>后续是一些子进程启动失败的异常处理逻辑，暂时不叙。</p>
</li>
</ul>
<h4 id="has-new-bits-u8-virgin-map"><a href="#has-new-bits-u8-virgin-map" class="headerlink" title="has_new_bits(u8 *virgin_map)"></a>has_new_bits(u8 *virgin_map)</h4><ul>
<li>检查有没有新路径或者某个路径的执行次数有所不同。</li>
<li>初始化current和virgin为trace_bits和virgin_map的u64首元素地址，设置ret的值为0</li>
<li>8个字节一组，每次从trace_bits，也就是共享内存里取出8个字节<ul>
<li>如果current不为0，且<code>current &amp; virgin</code>不为0，即代表current发现了新路径或者某条路径的执行次数和之前有所不同<ul>
<li>如果ret当前小于2<ul>
<li>取current的首字节地址为cur，virgin的首字节地址为vir</li>
<li>i的范围是0-7，比较<code>cur[i] &amp;&amp; vir[i] == 0xff</code>，如果有一个为真，则设置ret为2<ul>
<li>这代表发现了之前没有出现过的tuple</li>
<li><strong>注意==的优先级比&amp;&amp;要高，所以先判断vir[i]是否是0xff，即之前从未被覆盖到，然后再和cur[i]进行逻辑与</strong></li>
</ul>
</li>
<li>否则设置ret为1<ul>
<li>这代表仅仅只是改变了某个tuple的hit-count</li>
</ul>
</li>
</ul>
</li>
<li><code>*virgin &amp;= ~*current</code></li>
</ul>
</li>
<li>current和virgin移动到下一组8个字节，直到MAPSIZE全被遍历完。</li>
</ul>
</li>
<li>如果传入给has_new_bits的参数<code>virgin_map</code>是<code>virgin_bits</code>,且ret不为0，就设置bitmap_changed为1<ul>
<li>virgin_bits保存还没有被Fuzz覆盖到的byte，其初始值每位全被置位1,然后每次按字节置位。</li>
</ul>
</li>
<li>返回ret的值。</li>
</ul>
<h4 id="u32-count-bytes-u8-mem"><a href="#u32-count-bytes-u8-mem" class="headerlink" title="u32 count_bytes(u8 *mem)"></a>u32 count_bytes(u8 *mem)</h4><ul>
<li>初始化计数器ret的值为0，循环读取mem里的值，每次读取4个字节到u32变量v中</li>
<li>如果v为0，则代表这四个字节都是0，直接跳过，进入下一次循环</li>
<li>如果v不为0，则依次计算<code>v &amp; FF(0),v &amp; FF(1),v &amp; FF(2),v&amp;FF(3)</code>的结果，如果不为0，则计数器ret加一。<ul>
<li>#define FF(_b)  (0xff &lt;&lt; ((_b) &lt;&lt; 3))<ul>
<li><code>(_b) &lt;&lt; 3)</code>即<code>_b * 8</code></li>
<li>即<code>0x000000ff</code>左移<code>(_b * 8)</code>位</li>
<li>最终结果可以是<code>0x000000ff</code>,<code>0x0000ff00</code>,<code>0x00ff0000</code>,<code>0xff000000</code>其中之一</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="u8-run-target-char-argv-u32-timeout"><a href="#u8-run-target-char-argv-u32-timeout" class="headerlink" title="u8 run_target(char **argv, u32 timeout)"></a>u8 run_target(char **argv, u32 timeout)</h4><ul>
<li>先清空trace_bits[MAP_SIZE]，将其全置为0，也就是清空共享内存。</li>
<li>如果dumb_mode等于1，且no_forkserver，则直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向trace_bits写入EXEC_FAIL_SIG</li>
<li>否则，就向控制管道写入<code>prev_timed_out</code>的值，命令Fork server开始fork出一个子进程进行fuzz，然后从状态管道读取fork server返回的fork出的子进程的ID到<code>child_pid</code></li>
<li>无论实际执行的是上面两种的哪一种，在执行target期间，都设置计数器为timeout，如果超时，就杀死正在执行的子进程，并设置child_timed_out为1;</li>
<li>计算target执行时间exec_ms，并将total_execs这个执行次数计数器加一。</li>
<li>等待target执行结束，如果是dumb_mode，target执行结束的状态码将直接保存到status中，如果不是dumb_mode，则从状态管道中读取target执行结束的状态码。</li>
<li>classify_counts((u64 *) trace_bits)<ul>
<li>具体地，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入到buckets中，举个例子，如果某分支执行了1次，那么落入第2个bucket，其计数byte仍为1；如果某分支执行了4次，那么落入第5个bucket，其计数byte将变为8，等等。</li>
<li>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况.</li>
</ul>
</li>
<li>设置prev_timed_out的值为child_timed_out。</li>
<li>接着依据status的值，向调用者返回结果。<ul>
<li><code>WIFSIGNALED(status)</code>若为异常结束子进程返回的状态，则为真<ul>
<li><code>WTERMSIG(status)</code>取得子进程因信号而中止的信号代码<ul>
<li>如果child_timed_out为1，且状态码为<code>SIGKILL</code>，则返回<code>FAULT_TMOUT</code></li>
<li>否则返回<code>FAULT_CRASH</code></li>
</ul>
</li>
</ul>
</li>
<li>如果是dumb_mode，且trace_bits为EXEC_FAIL_SIG，就返回<code>FAULT_ERROR</code></li>
<li>如果<code>timeout</code>小于等于<code>exec_tmout</code>，且<code>slowest_exec_ms</code>小于<code>exec_ms</code>，设置<code>slowest_exec_ms</code>等于<code>exec_ms</code></li>
<li>返回<code>FAULT_NONE</code></li>
</ul>
</li>
</ul>
<h4 id="classify-counts-u64-mem"><a href="#classify-counts-u64-mem" class="headerlink" title="classify_counts(u64 *mem)"></a>classify_counts(u64 *mem)</h4><ul>
<li>8个字节一组去循环读入，直到遍历完整个mem<ul>
<li>每次取两个字节<code>u16 *mem16 = (u16 *) mem</code></li>
<li>i从0到3，计算<code>mem16[i]</code>的值，在<code>count_class_lookup16[mem16[i]]</code>里找到对应的取值，并赋值给<code>mem16[i]</code></li>
</ul>
</li>
</ul>
<h4 id="update-bitmap-score-struct-queue-entry-q"><a href="#update-bitmap-score-struct-queue-entry-q" class="headerlink" title="update_bitmap_score(struct queue_entry *q)"></a>update_bitmap_score(struct queue_entry *q)</h4><p>每当我们发现一个新的路径，都会调用这个函数来判断其是不是更加地favorable，这个favorable的意思是说是否包含最小的路径集合来遍历到所有bitmap中的位，我们专注于这些集合而忽略其他的。</p>
<ul>
<li>首先计算出这个case的fav_factor，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即执行时间和样例大小的乘积，以这两个指标来衡量权重。</li>
<li>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path<ul>
<li>然后检查对应于这个path的top_rated是否存在<ul>
<li><code>static struct queue_entry *top_rated[MAP_SIZE];                /* Top entries for bitmap bytes     */</code></li>
<li>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行时间和样例大小的乘积，哪个更小。<ul>
<li>如果<code>top_rated[i]</code>的更小，则代表<code>top_rated[i]</code>的更优，不做任何处理，继续遍历下一个path。</li>
<li>如果q更小，就将<code>top_rated[i]</code>原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</li>
<li><code>u8 *trace_mini;                     /* Trace bytes, if kept             */</code></li>
<li><code>u32 tc_ref;                         /* Trace bytes ref count            */</code></li>
</ul>
</li>
<li>然后设置<code>top_rated[i]</code>为q，即当前case，然后将其tc_ref的值加一</li>
<li>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过minimize_bits压缩，然后存到trace_mini字段里</li>
<li>设置score_changed为1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="void-minimize-bits-u8-dst-u8-src"><a href="#void-minimize-bits-u8-dst-u8-src" class="headerlink" title="void minimize_bits(u8 *dst, u8 *src)"></a>void minimize_bits(u8 *dst, u8 *src)</h4><p>将trace_bits压缩为较小的位图。<br>简单的理解就是把原本是包括了是否覆盖到和覆盖了多少次的byte，压缩成是否覆盖到的bit。<br>在看这个函数和下一个函数cull_queue之前，建议把<a href="https://blog.csdn.net/lxlmycsdnfree/article/details/78926359" target="_blank" rel="noopener">经典算法系列之(一) - BitMap [数据的压缩存储]</a>读完。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minimize_bits</span><span class="params">(u8 *dst, u8 *src)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    u32 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; MAP_SIZE) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(src++)) dst[i &gt;&gt; <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然dst是一个bitmap，但是实际上在这里我们还是用一个byte数组来操作它，所以就首先得做byte-&gt;bit的映射，比如说将src的前0-7个字节映射到dst的第一个字节(0-7位)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0&gt;&gt;3</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 1&gt;&gt;3</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 2&gt;&gt;3</span><br><span class="line">0</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; 7&gt;&gt;3</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 8&gt;&gt;3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>然后如果src里该字节的值不为0，i此时就代表这个字节的index索引，其与<code>0000 0111</code>相与，最终的结果都只在0-7之间，这样我们就可以知道这个index在0-7之间对应的具体的bit是哪一个，最后通过或运算将该位置位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0&amp;7</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 1&amp;7</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 2&amp;7</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 3&amp;7</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 4&amp;7</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 5&amp;7</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; 6&amp;7</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; 7&amp;7</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; 8&amp;7</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 9&amp;7</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h4><p>精简队列</p>
<ul>
<li>如果score_changed为0，即top_rated没有变化，或者dumb_mode,就直接返回</li>
<li>设置score_changed的值为0</li>
<li>创建u8 temp_v数组，大小为<code>MAP_SIZE除8</code>，并将其初始值设置为0xff，其每位如果为1就代表还没有被覆盖到，如果为0就代表以及被覆盖到了。</li>
<li>设置queued_favored为0，pending_favored为0</li>
<li>开始遍历queue队列，设置其favored的值都为0</li>
<li>将i从0到MAP_SIZE迭代，这个迭代其实就是筛选出一组queue entry，它们就能够覆盖到所有现在已经覆盖到的路径，而且这个case集合里的case要更小更快，这并不是最优算法，只能算是贪婪算法。<ul>
<li>这又是个不好懂的位运算，<code>temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))</code>与上面的差不多，中间的或运算改成了与，是为了检查该位是不是0，即判断该path对应的bit有没有被置位。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>如果<code>top_rated[i]</code>有值，且该path在temp_v里被置位<ul>
<li>就从temp_v中清除掉所有<code>top_rated[i]</code>覆盖到的path，将对应的bit置为0</li>
<li>设置<code>top_rated[i]-&gt;favored</code>为1，queued_favored计数器加一</li>
<li>如果<code>top_rated[i]</code>的was_fuzzed字段是0，代表其还没有fuzz过，则将pending_favored计数器加一</li>
</ul>
</li>
<li>遍历queue队列<ul>
<li>mark_as_redundant(q, !q-&gt;favored)<ul>
<li>也就是说，如果不是favored的case，就被标记成redundant_edges</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="mark-as-redundant-struct-queue-entry-q-u8-state"><a href="#mark-as-redundant-struct-queue-entry-q-u8-state" class="headerlink" title="mark_as_redundant(struct queue_entry *q, u8 state)"></a>mark_as_redundant(struct queue_entry *q, u8 state)</h4><ul>
<li>如果<code>state和q-&gt;fs_redundant</code>相等，就直接返回</li>
<li>设置<code>q-&gt;fs_redundant</code>的值为state，</li>
<li>如果state为1<ul>
<li>尝试创建<code>out_dir/queue/.state/redundant_edges/fname</code></li>
</ul>
</li>
<li>如果state为0<ul>
<li>尝试删除<code>out_dir/queue/.state/redundant_edges/fname</code></li>
</ul>
</li>
</ul>
<h4 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h4><p>在处理输入目录的末尾显示统计信息，以及一堆警告,以及几个硬编码的常量。</p>
<ul>
<li>依据之前从calibrate_case里得到的total_cal_us和total_cal_cycles，计算出单轮执行的时间avg_us，如果大于10000，就警告<code>&quot;The target binary is pretty slow! See %s/perf_tips.txt.&quot;</code><ul>
<li>如果avg_us大于50000，设置havoc_div为10 /* 0-19 execs/sec   */</li>
<li>大于20000，设置havoc_div为5 /* 20-49 execs/sec  */</li>
<li>如果大于10000，设置havoc_div为2 /* 50-100 execs/sec */</li>
</ul>
</li>
<li>如果不是resuming session，则对queue的大小和个数超限提出警告，且如果useless_at_start不为0，就警告有可以精简的样本。</li>
<li>如果timeout_given为0，则根据avg_us来计算出exec_tmout，<strong>注意这里avg_us的单位是微秒，而exec_tmout单位是毫秒，所以需要除以1000</strong><ul>
<li>avg_us &gt; 50000<ul>
<li>exec_tmout = avg_us * 2 / 1000</li>
</ul>
</li>
<li>avg_us &gt; 10000<ul>
<li>exec_tmout = avg_us * 3 / 1000</li>
</ul>
</li>
<li>exec_tmout = avg_us * 5 / 1000</li>
<li>然后在上面计算出来的exec_tmout和所有样例中执行时间最长的样例进行比较，取最大值赋给exec_tmout</li>
<li>如果exec_tmout大于EXEC_TIMEOUT，就设置exec_tmout = EXEC_TIMEOUT<ul>
<li>EXEC_TIMEOUT的值为1秒，即最大超时时间是1秒</li>
</ul>
</li>
<li>打印出<code>&quot;No -t option specified, so I&#39;ll use exec timeout of %u ms.&quot;, exec_tmout</code></li>
<li>设置timeout_given为1</li>
</ul>
</li>
<li>如果timeout_give不为0，且为3，代表这是resuming session，直接打印<code>&quot;Applying timeout settings from resumed session (%u ms).&quot;, exec_tmout</code>,此时的timeout_give是我们从历史记录里读取出的。</li>
<li>如果是dumb_mode且没有设置环境变量AFL_HANG_TMOUT<ul>
<li>设置hang_tmout为EXEC_TIMEOUT和<code>exec_tmout * 2 + 100</code>中的最小值</li>
</ul>
</li>
<li><code>All set and ready to roll!</code></li>
</ul>
<h4 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h4><p>resume时,请尝试查找要从其开始的队列位置,这仅在resume时以及当我们可以找到原始的fuzzer_stats时才有意义.</p>
<ul>
<li>如果不是resuming_fuzz，就直接返回</li>
<li>如果是in_place_resume,就打开<code>out_dir/fuzzer_stats</code>文件，否则打开<code>in_dir/../fuzzer_stats</code>文件</li>
<li>读这个文件的内容到tmp[4096]中，找到<code>cur_path</code>，并设置为ret的值，如果大于queued_paths就设置ret为0，返回ret。</li>
</ul>
<h4 id="void-write-stats-file-double-bitmap-cvg-double-stability-double-eps"><a href="#void-write-stats-file-double-bitmap-cvg-double-stability-double-eps" class="headerlink" title="void write_stats_file(double bitmap_cvg, double stability, double eps)"></a>void write_stats_file(double bitmap_cvg, double stability, double eps)</h4><p>更新统计信息文件以进行无人值守的监视</p>
<ul>
<li>创建文件<code>out_dir/fuzzer_stats</code></li>
<li>写入统计信息</li>
<li>start_time<ul>
<li>fuzz运行的开始时间，start_time / 1000</li>
</ul>
</li>
<li>last_update<ul>
<li>当前时间</li>
</ul>
</li>
<li>fuzzer_pid<ul>
<li>获取当前pid</li>
</ul>
</li>
<li>cycles_done<ul>
<li><code>queue_cycle</code>在<code>queue_cur</code>为空，即执行到当前队列尾的时候才增加1，所以这代表queue队列被完全变异一次的次数。</li>
</ul>
</li>
<li>execs_done<ul>
<li>total_execs，target的总的执行次数，每次<code>run_target</code>的时候会增加1</li>
</ul>
</li>
<li>execs_per_sec<ul>
<li>每秒执行的次数</li>
</ul>
</li>
<li>paths_total<ul>
<li>queued_paths在每次<code>add_to_queue</code>的时候会增加1，代表queue里的样例总数</li>
</ul>
</li>
<li>paths_favored<ul>
<li>queued_favored，有价值的路径总数</li>
</ul>
</li>
<li>paths_found<ul>
<li>queued_discovered在每次<code>common_fuzz_stuff</code>去执行一次fuzz时，发现新的interesting case的时候会增加1，代表在fuzz运行期间发现的新queue entry。</li>
</ul>
</li>
<li>paths_imported<ul>
<li>queued_imported是master-slave模式下，如果sync过来的case是interesting的，就增加1</li>
</ul>
</li>
<li>max_depth<ul>
<li>最大路径深度</li>
</ul>
</li>
<li>cur_path<ul>
<li>current_entry一般情况下代表的是正在执行的queue entry的整数ID,queue首节点的ID是0</li>
</ul>
</li>
<li>pending_favs<ul>
<li>pending_favored 等待fuzz的favored paths数</li>
</ul>
</li>
<li>pending_total<ul>
<li>pending_not_fuzzed 在queue中等待fuzz的case数</li>
</ul>
</li>
<li>variable_paths<ul>
<li>queued_variable在<code>calibrate_case</code>去评估一个新的test case的时候，如果发现这个case的路径是可变的，则将这个计数器加一，代表发现了一个可变case</li>
</ul>
</li>
<li>stability</li>
<li>bitmap_cvg</li>
<li>unique_crashes<ul>
<li>unique_crashes这是在<code>save_if_interesting</code>时，如果fault是FAULT_CRASH，就将unique_crashes计数器加一</li>
</ul>
</li>
<li>unique_hangs<ul>
<li>unique_hangs这是在<code>save_if_interesting</code>时，如果fault是FAULT_TMOUT，且exec_tmout小于hang_tmout，就以hang_tmout为超时时间再执行一次，如果还超时，就让hang计数器加一。</li>
</ul>
</li>
<li>last_path<ul>
<li>在<code>add_to_queue</code>里将一个新case加入queue时，就设置一次last_path_time为当前时间，<code>last_path_time / 1000</code></li>
</ul>
</li>
<li>last_crash<ul>
<li>同上，在unique_crashes加一的时候，last_crash也更新时间，<code>last_crash_time / 1000</code></li>
</ul>
</li>
<li>last_hang<ul>
<li>同上，在unique_hangs加一的时候，last_hang也更新时间，<code>last_hang_time / 1000</code></li>
</ul>
</li>
<li>execs_since_crash<ul>
<li>total_execs - last_crash_execs,这里last_crash_execs是在上一次crash的时候的总计执行了多少次</li>
</ul>
</li>
<li>exec_tmout<ul>
<li>配置好的超时时间，有三种可能的配置方式，见上文</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">"start_time        : %llu\n"</span></span><br><span class="line">           <span class="string">"last_update       : %llu\n"</span></span><br><span class="line">           <span class="string">"fuzzer_pid        : %u\n"</span></span><br><span class="line">           <span class="string">"cycles_done       : %llu\n"</span></span><br><span class="line">           <span class="string">"execs_done        : %llu\n"</span></span><br><span class="line">           <span class="string">"execs_per_sec     : %0.02f\n"</span></span><br><span class="line">           <span class="string">"paths_total       : %u\n"</span></span><br><span class="line">           <span class="string">"paths_favored     : %u\n"</span></span><br><span class="line">           <span class="string">"paths_found       : %u\n"</span></span><br><span class="line">           <span class="string">"paths_imported    : %u\n"</span></span><br><span class="line">           <span class="string">"max_depth         : %u\n"</span></span><br><span class="line">           <span class="string">"cur_path          : %u\n"</span> <span class="comment">/* Must match find_start_position() */</span></span><br><span class="line">           <span class="string">"pending_favs      : %u\n"</span></span><br><span class="line">           <span class="string">"pending_total     : %u\n"</span></span><br><span class="line">           <span class="string">"variable_paths    : %u\n"</span></span><br><span class="line">           <span class="string">"stability         : %0.02f%%\n"</span></span><br><span class="line">           <span class="string">"bitmap_cvg        : %0.02f%%\n"</span></span><br><span class="line">           <span class="string">"unique_crashes    : %llu\n"</span></span><br><span class="line">           <span class="string">"unique_hangs      : %llu\n"</span></span><br><span class="line">           <span class="string">"last_path         : %llu\n"</span></span><br><span class="line">           <span class="string">"last_crash        : %llu\n"</span></span><br><span class="line">           <span class="string">"last_hang         : %llu\n"</span></span><br><span class="line">           <span class="string">"execs_since_crash : %llu\n"</span></span><br><span class="line">           <span class="string">"exec_timeout      : %u\n"</span> <span class="comment">/* Must match find_timeout() */</span></span><br><span class="line">           <span class="string">"afl_banner        : %s\n"</span></span><br><span class="line">           <span class="string">"afl_version       : "</span> VERSION <span class="string">"\n"</span></span><br><span class="line">           <span class="string">"target_mode       : %s%s%s%s%s%s%s\n"</span></span><br><span class="line">           <span class="string">"command_line      : %s\n"</span></span><br><span class="line">           <span class="string">"slowest_exec_ms   : %llu\n"</span>,</span><br><span class="line">        start_time / <span class="number">1000</span>, get_cur_time() / <span class="number">1000</span>, getpid(),</span><br><span class="line">        queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">        queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">        max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">        queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">        unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">        last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">        exec_tmout, use_banner,</span><br><span class="line">        qemu_mode ? <span class="string">"qemu "</span> : <span class="string">""</span>, dumb_mode ? <span class="string">" dumb "</span> : <span class="string">""</span>,</span><br><span class="line">        no_forkserver ? <span class="string">"no_forksrv "</span> : <span class="string">""</span>, crash_mode ? <span class="string">"crash "</span> : <span class="string">""</span>,</span><br><span class="line">        persistent_mode ? <span class="string">"persistent "</span> : <span class="string">""</span>, deferred_mode ? <span class="string">"deferred "</span> : <span class="string">""</span>,</span><br><span class="line">        (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">         persistent_mode || deferred_mode) ? <span class="string">""</span> : <span class="string">"default"</span>,</span><br><span class="line">        orig_cmdline, slowest_exec_ms);</span><br></pre></td></tr></table></figure>
<ul>
<li>统计子进程的资源用量并写入。</li>
</ul>
<h4 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h4><p>保存自动生成的extras</p>
<ul>
<li>如果auto_changed为0，则直接返回</li>
<li>如果不为0，就设置为0，然后创建名为<code>alloc_printf(&quot;%s/queue/.state/auto_extras/auto_%06u&quot;, out_dir, i);</code>的文件，并写入a_extras的内容。</li>
</ul>
<h3 id="Fuzz执行"><a href="#Fuzz执行" class="headerlink" title="Fuzz执行"></a>Fuzz执行</h3><h4 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h4><ul>
<li>首先精简队列<code>cull_queue</code></li>
<li>然后如果<code>queue_cur</code>为空，代表所有queue都被执行完一轮<ul>
<li>设置queue_cycle计数器加一，即代表所有queue被完整执行了多少轮。</li>
<li>设置current_entry为0，和queue_cur为queue首元素，开始新一轮fuzz。</li>
<li>如果是resume fuzz情况，则先检查seek_to是否为空，如果不为空，就从seek_to指定的queue项开始执行。</li>
<li>刷新展示界面<code>show_stats</code></li>
<li>如果在一轮执行之后的queue里的case数，和执行之前一样，代表在完整的一轮执行里都没有发现任何一个新的case<ul>
<li>如果use_splicing为1，就设置cycles_wo_finds计数器加1</li>
<li>否则，设置use_splicing为1，代表我们接下来要通过splice重组queue里的case。</li>
</ul>
</li>
</ul>
</li>
<li>执行<code>skipped_fuzz = fuzz_one(use_argv)</code>来对queue_cur进行一次测试<ul>
<li>注意fuzz_one并不一定真的执行当前queue_cur，它是有一定策略的，如果不执行，就直接返回1，否则返回0</li>
</ul>
</li>
<li>如果skipped_fuzz为0，且存在sync_id<ul>
<li>sync_interval_cnt计数器加一，如果其结果是SYNC_INTERVAL(默认是5)的倍数，就进行一次sync</li>
</ul>
</li>
<li><code>queue_cur = queue_cur-&gt;next;current_entry++;</code>，开始测试下一个queue</li>
</ul>
<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><ul>
<li><p>如果<code>pending_favored</code>不为0，则对于queue_cur被fuzz过或者不是favored的，有99%的几率直接返回1。</p>
</li>
<li><p>如果<code>pending_favored</code>为0且queued_paths(即queue里的case总数)大于10</p>
<ul>
<li>如果queue_cycle大于1且queue_cur没有被fuzz过，则有75%的概率直接返回1</li>
<li>如果queue_cur被fuzz过，否则有95%的概率直接返回1</li>
</ul>
</li>
<li><p>设置len为<code>queue_cur-&gt;len</code></p>
</li>
<li><p>打开该case对应的文件，并通过mmap映射到内存里，地址赋值给<code>in_buf</code>和<code>orig_in</code></p>
</li>
<li><p>分配len大小的内存，并初始化为全0，然后将地址赋值给out_buf</p>
</li>
<li><p><strong>CALIBRATION阶段</strong></p>
</li>
<li><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case再次校准。</p>
</li>
<li><p><strong>TRIMMING阶段</strong></p>
</li>
<li><p>如果该case没有trim过，</p>
<ul>
<li>调用函数<code>trim_case(argv, queue_cur, in_buf)</code>进行trim(修剪)</li>
<li>设置queue_cur的trim_done为1</li>
<li>重新读取一次<code>queue_cur-&gt;len</code>到len中</li>
</ul>
</li>
<li><p>将in_buf拷贝len个字节到out_buf中</p>
</li>
<li><p><strong>PERFORMANCE SCORE阶段</strong></p>
</li>
<li><p>perf_score = <code>calculate_score(queue_cur)</code></p>
</li>
<li><p>如果skip_deterministic为1，或者queue_cur被fuzz过，或者queue_cur的passed_det为1，则跳转去havoc_stage阶段</p>
</li>
<li><p>设置doing_det为1</p>
</li>
<li><p><strong>SIMPLE BITFLIP (+dictionary construction)阶段</strong></p>
</li>
<li><p>下面这个宏很有意思</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line">    u8* _arf = (u8*)(_ar); \</span><br><span class="line">    u32 _bf = (_b); \</span><br><span class="line">    _arf[(_bf) &gt;&gt; <span class="number">3</span>] ^= (<span class="number">128</span> &gt;&gt; ((_bf) &amp; <span class="number">7</span>)); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>设置stage_name为<code>bitflip 1/1</code>,_ar的取值是out_buf,而_bf的取值在[0: len &lt;&lt; 3)<br>所以用<code>_bf &amp; 7</code>能够得到<code>0,1,2...7 0,1,2...7</code>这样的取值一共len组，然后<code>(_bf) &gt;&gt; 3</code>又将[0: len&lt;&lt;3)映射回了[0: len)，对应到buf里的每个byte，如图:<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-27-023812.jpg" alt=""><br>所以在从<code>0-len*8</code>的遍历过程中会通过亦或运算，依次将每个位翻转，然后执行一次<code>common_fuzz_stuff</code>，然后再翻转回来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stage_max = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。<br>比如对于SQL的<code>SELECT *</code>，如果<code>SELECT</code>被破坏，则肯定和正确的路径不一致，而被破坏之后的路径却肯定是一样的，比如<code>AELECT</code>和<code>SBLECT</code>，显然都是无意义的，而只有不破坏token，才有可能出现和原始执行路径一样的结果，所以AFL在这里就是在猜解关键字token。</p>
</li>
<li><p>token默认最小是3，最大是32,每次发现新token时，通过<code>maybe_add_auto</code>添加到<code>a_extras</code>数组里。</p>
</li>
<li><p><code>stage_finds[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中新发现的路径和Crash总和</p>
</li>
<li><p><code>stage_cycles[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中执行的target次数<code>stage_max</code></p>
</li>
<li><p>设置stage_name为<code>bitflip 2/1</code>,原理和之前一样，只是这次是连续翻转相邻的两位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后保存结果到<code>stage_finds[STAGE_FLIP2]和stage_cycles[STAGE_FLIP2]</code>里。</p>
</li>
<li><p>同理，设置stage_name为<code>bitflip 4/1</code>，翻转连续的四位并记录。</p>
</li>
<li><p>生成effector map</p>
<ul>
<li>在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</li>
<li>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</li>
<li>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</li>
<li>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</li>
<li>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</li>
</ul>
</li>
<li><p>设置stage_name为<code>bitflip 8/8</code>，以字节为单位，直接通过和<code>0xff</code>亦或运算去翻转整个字节的位，然后执行一次，并记录。</p>
</li>
<li><p>设置stage_name为<code>bitflip 16/8</code>，设置<code>stage_max</code>为<code>len - 1</code>，以字为单位和<code>0xffff</code>进行亦或运算，去翻转相邻的两个字节(即一个字的)的位。</p>
<ul>
<li>这里要注意在翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一个字。</li>
<li>common_fuzz_stuff执行变异后的结果，然后还原。</li>
</ul>
</li>
<li><p>同理，设置stage_name为<code>bitflip 32/8</code>，然后设置<code>stage_max</code>为<code>len - 3</code>，以双字为单位，直接通过和<code>0xffffffff</code>亦或运算去相邻四个字节的位，然后执行一次，并记录。</p>
<ul>
<li>在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一组双字。</li>
</ul>
</li>
<li><p><strong>ARITHMETIC INC/DEC</strong></p>
</li>
<li><p>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</p>
</li>
<li><p>arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</p>
</li>
<li><p>arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</p>
</li>
<li><p>arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</p>
</li>
<li><p>加减变异的上限，在config.h中的宏ARITH_MAX定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p>
</li>
<li><p>此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p>
</li>
<li><p><strong>INTERESTING VALUES</strong></p>
</li>
<li><p>下一个阶段是interest，具体可分为：</p>
</li>
<li><p>interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</p>
</li>
<li><p>interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</p>
</li>
<li><p>interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</p>
</li>
<li><p>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数,这些数的定义在config.h文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;</span><br><span class="line"><span class="keyword">static</span> s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line"><span class="keyword">static</span> s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。</p>
</li>
<li><p><strong>DICTIONARY STUFF</strong><br>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</p>
</li>
<li><p>user extras(over),从头开始,将用户提供的tokens依次替换到原文件中,stage_max为<code>extras_cnt * len</code></p>
</li>
<li><p>user extras(insert),从头开始,将用户提供的tokens依次插入到原文件中,stage_max为<code>extras_cnt * len</code></p>
</li>
<li><p>auto extras(over),从头开始,将自动检测的tokens依次替换到原文件中,stage_max为<code>MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</code></p>
</li>
<li><p>其中，用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶段。</p>
</li>
<li><p><strong>RANDOM HAVOC</strong></p>
</li>
<li><p>对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p>
</li>
<li><p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p>
</li>
<li><p>随机选取某个bit进行翻转</p>
</li>
<li><p>随机选取某个byte，将其设置为随机的interesting value</p>
</li>
<li><p>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</p>
</li>
<li><p>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</p>
</li>
<li><p>随机选取某个byte，对其减去一个随机数</p>
</li>
<li><p>随机选取某个byte，对其加上一个随机数</p>
</li>
<li><p>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</p>
</li>
<li><p>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</p>
</li>
<li><p>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</p>
</li>
<li><p>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</p>
</li>
<li><p>随机选取某个byte，将其设置为随机数</p>
</li>
<li><p>随机删除一段bytes</p>
</li>
<li><p>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</p>
</li>
<li><p>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</p>
</li>
<li><p>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</p>
</li>
<li><p>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</p>
</li>
<li><p>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</p>
</li>
<li><p>splice</p>
</li>
<li><p>设置ret_val的值为0</p>
</li>
<li><p>如果queue_cur通过了评估，且was_fuzzed字段是0，就设置<code>queue_cur-&gt;was_fuzzed</code>为1，然后pending_not_fuzzed计数器减一</p>
</li>
<li><p>如果queue_cur是favored, pending_favored计数器减一。</p>
<h4 id="sync-fuzzers-char-argv"><a href="#sync-fuzzers-char-argv" class="headerlink" title="sync_fuzzers(char **argv)"></a>sync_fuzzers(char **argv)</h4><p>这个函数其实就是读取其他sync文件夹下的queue文件，然后保存到自己的queue里。</p>
</li>
<li><p>打开<code>sync_dir</code>文件夹</p>
</li>
<li><p>while循环读取该文件夹下的目录和文件<code>while ((sd_ent = readdir(sd)))</code></p>
<ul>
<li>跳过<code>.</code>开头的文件和<code>sync_id</code>即我们自己的输出文件夹</li>
<li>读取<code>out_dir/.synced/sd_ent-&gt;d_name</code>文件即<code>id_fd</code>里的前4个字节到<code>min_accept</code>里，设置<code>next_min_accept</code>为<code>min_accept</code>，这个值代表之前从这个文件夹里读取到的最后一个queue的id。</li>
<li>设置stage_name为<code>sprintf(stage_tmp, &quot;sync %u&quot;, ++sync_cnt);</code>，设置stage_cur为0，stage_max为0</li>
<li>循环读取<code>sync_dir/sd_ent-&gt;d_name/queue</code>文件夹里的目录和文件<ul>
<li>同样跳过<code>.</code>开头的文件和标识小于min_accept的文件，因为这些文件应该已经被sync过了。</li>
<li>如果标识<code>syncing_case</code>大于等于next_min_accept，就设置next_min_accept为<code>syncing_case + 1</code></li>
<li>开始同步这个case<ul>
<li>如果case大小为0或者大于MAX_FILE(默认是1M),就不进行sync。</li>
<li>否则mmap这个文件到内存mem里，然后<code>write_to_testcase(mem, st.st_size)</code>,并run_target,然后通过save_if_interesting来决定是否要导入这个文件到自己的queue里，如果发现了新的path，就导入。<ul>
<li>设置syncing_party的值为<code>sd_ent-&gt;d_name</code></li>
<li>如果save_if_interesting返回1，queued_imported计数器就加1</li>
</ul>
</li>
</ul>
</li>
<li>stage_cur计数器加一，如果stage_cur是stats_update_freq的倍数，就刷新一次展示界面。</li>
</ul>
</li>
<li>向id_fd写入当前的<code>next_min_accept</code>值</li>
</ul>
</li>
<li><p>总结来说，这个函数就是先读取有哪些fuzzer文件夹，然后读取其他fuzzer文件夹下的queue文件夹里的case，并依次执行，如果发现了新path，就保存到自己的queue文件夹里，而且将最后一个sync的case id写入到<code>.synced/其他fuzzer文件夹名</code>文件里，以避免重复运行。</p>
</li>
</ul>
<h4 id="trim-case-char-argv-struct-queue-entry-q-u8-in-buf"><a href="#trim-case-char-argv-struct-queue-entry-q-u8-in-buf" class="headerlink" title="trim_case(char **argv, struct queue_entry *q, u8 *in_buf)"></a>trim_case(char **argv, struct queue_entry *q, u8 *in_buf)</h4><ul>
<li>如果这个case的大小len小于5字节，就直接返回</li>
<li>设置stage_name的值为tmp，在bytes_trim_in的值里加上len，bytes_trim_in代表被trim过的字节数</li>
<li>计算len_p2，其值是大于等于q-&gt;len的第一个2的幂次。（eg.如果len是5704,那么len_p2就是8192）</li>
<li>取<code>len_p2的1/16</code>为remove_len，这是起始步长。</li>
<li>进入while循环，终止条件是remove_len小于终止步长<code>len_p2的1/1024</code>,<strong>每轮循环步长会除2.</strong><ul>
<li>设置remove_pos的值为remove_len</li>
<li>读入<code>&quot;trim %s/%s&quot;, DI(remove_len), DI(remove_len)</code>到tmp中, 即stage_name = “trim 512/512”</li>
<li>设置stage_cur为0，stage_max为<code>q-&gt;len / remove_len</code></li>
<li>进入while循环，<code>remove_pos &lt; q-&gt;len</code>,即每次前进remove_len个步长，直到整个文件都被遍历完为止。<ul>
<li>由in_buf中remove_pos处开始，向后跳过remove_len个字节，写入到<code>.cur_input</code>里，然后运行一次<code>fault = run_target</code>，trim_execs计数器加一</li>
<li>由所得trace_bits计算出一个cksum，和<code>q-&gt;exec_cksum</code>比较<ul>
<li>如果相等<ul>
<li>从<code>q-&gt;len</code>中减去remove_len个字节，并由此重新计算出一个<code>len_p2</code>，这里注意一下<code>while (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES))</code></li>
<li>将<code>in_buf+remove_pos+remove_len</code>到最后的字节，前移到<code>in_buf+remove_pos</code>处，等于删除了remove_pos向后的remove_len个字节。</li>
<li>如果needs_write为0，则设置其为1，并保存当前trace_bits到clean_trace中。</li>
</ul>
</li>
<li>如果不相等<ul>
<li>remove_pos加上remove_len，即前移remove_len个字节。<strong>注意，如果相等，就无需前移</strong></li>
</ul>
</li>
</ul>
</li>
<li>注意trim过程可能比较慢，所以每执行stats_update_freq次，就刷新一次显示界面<code>show_stats</code></li>
<li>stage_cur加一</li>
</ul>
</li>
</ul>
</li>
<li>如果needs_write为1<ul>
<li>删除原来的q-&gt;fname，创建一个新的q-&gt;fname，将in_buf里的内容写入，然后用clean_trace恢复trace_bits的值。</li>
<li>进行一次update_bitmap_score</li>
</ul>
</li>
<li>返回fault</li>
</ul>
<h4 id="u32-calculate-score-struct-queue-entry-q"><a href="#u32-calculate-score-struct-queue-entry-q" class="headerlink" title="u32 calculate_score(struct queue_entry *q)"></a>u32 calculate_score(struct queue_entry *q)</h4><p>根据queue entry的执行速度、覆盖到的path数和路径深度来评估出一个得分，这个得分perf_score在后面havoc的时候使用。<br>前面的没什么好说的，这里的<code>q-&gt;depth</code>解释一下，它在每次add_to_queue的时候，会设置为<code>cur_depth+1</code>，而cur_depth是一个全局变量，一开始的初始值为0。</p>
<ul>
<li>处理输入时<ul>
<li>在read_testcases的时候会调用add_to_queue，此时所有的input case的queue depth都会被设置为1。</li>
</ul>
</li>
<li>fuzz_one时<ul>
<li>然后在后面fuzz_one的时候，会先设置cur_depth为当前queue的depth，然后这个queue经过mutate之后调用save_if_interesting,如果是interesting case，就会被add_to_queue，此时就建立起了queue之间的关联关系，所以由当前queue变异加入的新queue，深度都在当前queue的基础上再增加。</li>
</ul>
</li>
</ul>
<h4 id="u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len"><a href="#u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len" class="headerlink" title="u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)"></a>u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)</h4><p>简单的说就是写入文件并执行，然后处理结果，如果出现错误，就返回1.</p>
<ul>
<li>如果定义了<code>post_handler</code>,就通过<code>out_buf = post_handler(out_buf, &amp;len)</code>处理一下out_buf，如果out_buf或者len有一个为0，则直接返回0<ul>
<li><strong>这里其实很有价值，尤其是如果需要对变异完的queue，做一层wrapper再写入的时候。</strong></li>
</ul>
</li>
<li>write_to_testcase(out_buf, len)</li>
<li>fault = run_target(argv, exec_tmout)</li>
<li>如果fault是FAULT_TMOUT<ul>
<li>如果<code>subseq_tmouts++ &gt; TMOUT_LIMIT</code>（默认250），就将cur_skipped_paths加一，直接返回1</li>
<li>subseq_tmout是连续超时数</li>
</ul>
</li>
<li>否则设置subseq_tmouts为0</li>
<li>如果skip_requested为1<ul>
<li>设置skip_requested为0，然后将cur_skipped_paths加一，直接返回1</li>
</ul>
</li>
<li>queued_discovered += save_if_interesting(argv, out_buf, len, fault)，即如果发现了新的路径才会加一。</li>
<li>如果stage_cur除以stats_update_freq余数是0，或者其加一等于stage_max，就更新展示界面<code>show_stats</code></li>
<li>返回0</li>
</ul>
<h4 id="void-write-to-testcase-void-mem-u32-len"><a href="#void-write-to-testcase-void-mem-u32-len" class="headerlink" title="void write_to_testcase(void *mem, u32 len)"></a>void write_to_testcase(void *mem, u32 len)</h4><p>将从<code>mem</code>中读取<code>len</code>个字节，写入到<code>.cur_input</code>中</p>
<h4 id="u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault"><a href="#u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault" class="headerlink" title="u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)"></a>u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)</h4><p>检查这个case的执行结果是否是interesting的，决定是否保存或跳过。如果保存了这个case，则返回1，否则返回0<br>以下分析不包括crash_mode，暂时略过以简洁</p>
<ul>
<li>设置keeping等于0</li>
<li><code>hnb = has_new_bits(virgin_bits)</code>，如果没有新的path发现或者path命中次数相同，就直接返回0</li>
<li>否则，将case保存到<code>fn = alloc_printf(&quot;%s/queue/id:%06u,%s&quot;, out_dir, queued_paths, describe_op(hnb))</code>文件里</li>
<li><code>add_to_queue(fn, len, 0);</code>将其添加到队列里</li>
<li>如果hnb的值是2，代表发现了新path，设置刚刚加入到队列里的queue的has_new_cov字段为1，即<code>queue_top-&gt;has_new_cov = 1</code>，然后queued_with_cov计数器加一</li>
<li>保存hash到其exec_cksum</li>
<li>评估这个queue，<code>calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0)</code></li>
<li>设置keeping值为1.</li>
<li>根据fault结果进入不同的分支<ul>
<li>FAULT_TMOUT<ul>
<li>设置total_tmouts计数器加一</li>
<li>如果unique_hangs的个数超过能保存的最大数量<code>KEEP_UNIQUE_HANG</code>，就直接返回keeping的值</li>
<li>如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整。</li>
<li>如果没有发现新的超时路径，就直接返回keeping</li>
<li>否则，代表发现了新的超时路径，unique_tmouts计数器加一</li>
<li>如果hang_tmout大于exec_tmout，则以hang_tmout为timeout，重新执行一次runt_target<ul>
<li>如果结果为<code>FAULT_CRASH</code>，就跳转到keep_as_crash</li>
<li>如果结果不是<code>FAULT_TMOUT</code>，就返回keeping，否则就使<code>unique_hangs</code>计数器加一，然后更新last_hang_time的值，并保存到<code>alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir, unique_hangs, describe_op(0))</code>文件。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>total_crashes计数器加一</li>
<li>如果unique_crashes大于能保存的最大数量<code>KEEP_UNIQUE_CRASH</code>即5000，就直接返回keeping的值</li>
<li>同理，如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整</li>
<li>如果没有发现新的crash路径，就直接返回keeping</li>
<li>否则，代表发现了新的crash路径，unique_crashes计数器加一，并将结果保存到<code>alloc_printf(&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;, out_dir,unique_crashes, kill_signal, describe_op(0))</code>文件。</li>
<li>更新last_crash_time和last_crash_execs</li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常</li>
</ul>
</li>
<li>对于其他情况，直接返回keeping</li>
</ul>
</li>
</ul>
<h4 id="simplify-trace-u64-mem"><a href="#simplify-trace-u64-mem" class="headerlink" title="simplify_trace(u64 *mem)"></a>simplify_trace(u64 *mem)</h4><ul>
<li>按8个字节为一组循环读入，直到完全读取完mem<ul>
<li>如果mem不为空<ul>
<li>i从0-7，<code>mem8[i] = simplify_lookup[mem8[i]]</code>，代表规整该路径的命中次数到指令值，这个路径如果没有命中，就设置为1，如果命中了，就设置为128，即二进制的<code>1000 0000</code></li>
</ul>
</li>
<li>否则设置mem为<code>0x0101010101010101ULL</code>，即代表这8个字节代表的path都没有命中，每个字节的值被置为1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 simplify_lookup[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">        [<span class="number">0</span>]         = <span class="number">1</span>,</span><br><span class="line">        [<span class="number">1</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="通信和覆盖率信息的记录"><a href="#通信和覆盖率信息的记录" class="headerlink" title="通信和覆盖率信息的记录"></a>通信和覆盖率信息的记录</h2><h3 id="关键变量和常量"><a href="#关键变量和常量" class="headerlink" title="关键变量和常量"></a>关键变量和常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.bss:000000000060208F unk_60208F      db    ? ;               ; DATA XREF: deregister_tm_clones↑o</span><br><span class="line">.bss:0000000000602090 __afl_area_ptr  dq ?                    ; DATA XREF: __afl_maybe_log+4↑r</span><br><span class="line">.bss:0000000000602090                                         ; __afl_maybe_log+48↑w ...</span><br><span class="line">.bss:0000000000602098 __afl_prev_loc  dq ?                    ; DATA XREF: __afl_maybe_log:__afl_store↑r</span><br><span class="line">.bss:0000000000602098                                         ; __afl_maybe_log+17↑w ...</span><br><span class="line">.bss:00000000006020A0 ; __pid_t _afl_fork_pid</span><br><span class="line">.bss:00000000006020A0 __afl_fork_pid  dd ?                    ; DATA XREF: __afl_maybe_log+1C6↑w</span><br><span class="line">.bss:00000000006020A0                                         ; __afl_maybe_log+1D3↑o ...</span><br><span class="line">.bss:00000000006020A4 ; int _afl_temp</span><br><span class="line">.bss:00000000006020A4 __afl_temp      dd ?                    ; DATA XREF: __afl_maybe_log+174↑o</span><br><span class="line">.bss:00000000006020A4                                         ; __afl_maybe_log+198↑o ...</span><br><span class="line">.bss:00000000006020A8 __afl_setup_failure db ?                ; DATA XREF: __afl_maybe_log:__afl_setup↑r</span><br><span class="line">.bss:00000000006020A8                                         ; __afl_maybe_log:__afl_setup_abort↑w</span><br><span class="line">...</span><br><span class="line">.text:0000000000400DEF ; char AFL_SHM_ENV[]</span><br><span class="line">.text:0000000000400DEF _AFL_SHM_ENV    db &#39;__AFL_SHM_ID&#39;,0     ; DATA XREF: __afl_maybe_log+11F↑o</span><br><span class="line">.text:0000000000400DEF                                         ; Alternative name is &#39;.AFL_VARS&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>__afl_area_ptr<ul>
<li>存储共享内存的首地址</li>
</ul>
</li>
<li>__afl_prev_loc<ul>
<li>存储上一个位置，即上一次R(MAP_SIZE)生成的随机数的值</li>
</ul>
</li>
<li>__afl_fork_pid<ul>
<li>存储fork出来的子进程的pid</li>
</ul>
</li>
<li>__afl_temp<ul>
<li>临时buffer</li>
</ul>
</li>
<li>_AFL_SHM_ENV<ul>
<li>申请的共享内存的shm_id被设置为环境变量<code>__AFL_SHM_ID</code>的值，所以通过这个环境变量来获取shm_id，然后进一步得到共享内存。</li>
</ul>
</li>
</ul>
<h3 id="trampoline-fmt-64"><a href="#trampoline-fmt-64" class="headerlink" title="trampoline_fmt_64"></a>trampoline_fmt_64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004009C0                 lea     rsp, [rsp-98h]</span><br><span class="line">.text:00000000004009C8                 mov     [rsp+98h+var_98], rdx</span><br><span class="line">.text:00000000004009CC                 mov     [rsp+98h+var_90], rcx</span><br><span class="line">.text:00000000004009D1                 mov     [rsp+98h+var_88], rax</span><br><span class="line">.text:00000000004009D6                 mov     rcx, 2359h----&gt;R(MAP_SIZE)</span><br><span class="line">.text:00000000004009DD                 call    __afl_maybe_log</span><br><span class="line">.text:00000000004009E2                 mov     rax, [rsp+98h+var_88]</span><br><span class="line">.text:00000000004009E7                 mov     rcx, [rsp+98h+var_90]</span><br><span class="line">.text:00000000004009EC                 mov     rdx, [rsp+98h+var_98]</span><br><span class="line">.text:00000000004009F0                 lea     rsp, [rsp+98h]</span><br></pre></td></tr></table></figure>
<p>插入的trampoline_fmt_64只有在<code>mov rcx, xxx</code>这里不同，其xxx的取值就是随机数R(MAP_SIZE),以此来标识与区分每个分支点，然后传入<code>__afl_maybe_log</code>作为第二个参数调用这个函数。</p>
<h3 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log"></a>__afl_maybe_log</h3><p>直接看汇编，还是很好理解的</p>
<ul>
<li>首先检查<code>_afl_area_ptr</code>是否为0，即是否共享内存已经被设置了。<strong>换句话说，只有第一个__afl_maybe_log会执行这个if里的代码</strong><ul>
<li>如果<code>_afl_area_ptr</code>为0，即共享内存还没被设置，则判断<code>_afl_setup_failure</code>是否为真，如果为真，则代表setup失败，直接返回。<ul>
<li>读取<code>_afl_global_area_ptr</code>的值<ul>
<li>如果不为0，则赋值给<code>_afl_area_ptr</code></li>
<li>否则<ul>
<li>首先读取环境变量<code>__AFL_SHM_ID</code>，默认是个字符串，atoi转一下，得到shm_id，然后通过shmat启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间，将得到的地址，保存到<code>_afl_area_ptr</code>和<code>_afl_global_area_ptr</code>中。</li>
<li>然后通过<code>FORKSRV_FD+1</code>即199这个文件描述符，向状态管道中写入4个字节的值，用来告知afl fuzz，fork server成功启动，等待下一步指示。</li>
<li>进入<code>__afl_fork_wait_loop</code>循环，从<code>FORKSRV</code>即198中读取字节到<code>_afl_temp</code>，直到读取到4个字节，这代表afl fuzz命令我们新建进程执行一次测试。<ul>
<li>fork出子进程，原来的父进程充当fork server来和fuzz进行通信，而子进程则继续执行target。</li>
<li>父进程即fork server将子进程的pid写入到状态管道，告知fuzz。</li>
<li>然后父进程即fork server等待子进程结束，并保存其执行结果到<code>_afl_temp</code>中，然后将子进程的执行结果，从<code>_afl_temp</code>写入到状态管道，告知fuzz。</li>
<li>父进程不断轮询<code>__afl_fork_wait_loop</code>循环，不断从控制管道读取，直到fuzz端命令fork server进行新一轮测试。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果<code>_afl_area_ptr</code>不为0，即共享内存已经被设置好了。那么就跳过上面的if，只执行<code>__afl_store</code>逻辑，伪代码如下:<ul>
<li>简单的说，就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将prev_location设置为<code>cur_location &gt;&gt; 1;</code></li>
<li>因此，AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为MAP_SIZE=64K，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>另外，比较有意思的是，AFL需要将cur_location右移1位后，再保存到prev_location中。官方文档中解释了这样做的原因。假设target中存在A-&gt;A和B-&gt;B这样两个跳转，如果不右移，那么这两个分支对应的异或后的key都是0，从而无法区分；另一个例子是A-&gt;B和B-&gt;A，如果不右移，这两个分支对应的异或后的key也是相同的。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __usercall _afl_maybe_log@&lt;al&gt;(<span class="keyword">char</span> a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  v19 = _afl_area_ptr;</span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure )</span><br><span class="line">      <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">    v19 = _afl_global_area_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 = getenv(<span class="string">"__AFL_SHM_ID"</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v22 || (v23 = atoi(v22), v24 = shmat(v23, <span class="number">0L</span>L, <span class="number">0</span>), v24 == (<span class="keyword">void</span> *)<span class="number">-1L</span>L) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 = v29;</span><br><span class="line">        <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _afl_area_ptr = (__int64)v24;</span><br><span class="line">      _afl_global_area_ptr = v24;</span><br><span class="line">      v28 = (__int64)v24;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL) == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">read</span>(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4u</span>LL) != <span class="number">4</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          LODWORD(v26) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( v26 &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v26 )</span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = v26;</span><br><span class="line">          <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4u</span>LL);</span><br><span class="line">          v25 = _afl_fork_pid;</span><br><span class="line">          LODWORD(v27) = waitpid(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v27 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(v25);</span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:</span><br><span class="line">      <span class="built_in">close</span>(<span class="number">198</span>);</span><br><span class="line">      <span class="built_in">close</span>(<span class="number">199</span>);</span><br><span class="line">      v19 = v28;</span><br><span class="line">      v18 = v29;</span><br><span class="line">      a2 = v30;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v20 = _afl_prev_loc ^ a2;</span><br><span class="line">  _afl_prev_loc ^= v20;</span><br><span class="line">  _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++*(_BYTE *)(v19 + v20);</span><br><span class="line">  <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>strrchr</p>
<ul>
<li><code>char *strrchr(const char *str, int c)</code> 在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</li>
</ul>
</li>
<li><p>strlen</p>
<ul>
<li><code>unsigned int strlen (char *s)</code> 用来计算指定的字符串s的长度，不包括结束字符”\0”。</li>
<li>注意：strlen() 函数计算的是字符串的实际长度，遇到第一个’\0’结束。如果你只定义没有给它赋初值，这个结果是不定的，它会从首地址一直找下去，直到遇到’\0’停止。而sizeof返回的是变量声明后所占的内存数，不是实际长度，此外sizeof不是函数，仅仅是一个操作符，strlen()是函数。</li>
</ul>
</li>
<li><p>DFL_ck_strdup</p>
<ul>
<li>Create a buffer with a copy of a string. Returns NULL for NULL inputs.</li>
<li><code>size = strlen((char*)str) + 1;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALLOC_MAGIC_C1-&gt; 00 ff 00 ff   size-&gt; 2e 00 00 00   ret-&gt; 2f 55 73 65   72 73 2f 73   │ ····.···&#x2F;Users&#x2F;s │</span><br><span class="line">61 6b 75 72   61 2f 67 69   74 73 6f 75   72 63 65 2f   │ akura&#x2F;gitsource&#x2F; │</span><br><span class="line">41 46 4c 2f   63 6d 61 6b   65 2d 62 75   69 6c 64 2d   │ AFL&#x2F;cmake-build- │</span><br><span class="line">64 65 62 75   67 00 ALLOC_MAGIC_C2-&gt; f0 00   00 00 00 00   00 00 00 00   │ debug··········· │</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>snprintf()</p>
<ul>
<li><code>int snprintf(char *str, int n, char * format [, argument, ...]);</code>函数用于将格式化的数据写入字符串</li>
<li>str为要写入的字符串；n为要写入的字符的最大数目，超过n会被截断；format为格式化字符串，与printf()函数相同；argument为变量。</li>
<li><a href="http://brg-liuwei.github.io/tech/2014/09/29/snprintf.html" target="_blank" rel="noopener">http://brg-liuwei.github.io/tech/2014/09/29/snprintf.html</a><ul>
<li>重点理解snprintf函数的返回值，不是实际打印出来的长度，而是实际应该打印的长度。</li>
</ul>
</li>
<li><a href="https://forcemz.net/cxx/2019/04/29/StringFormattingTalk/" target="_blank" rel="noopener">https://forcemz.net/cxx/2019/04/29/StringFormattingTalk/</a><ul>
<li>snprintf的可能的一种实现，及其可能存在的安全问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>DFL_ck_alloc</p>
<ul>
<li>Allocate a buffer, returning zeroed memory.<ul>
<li>DFL_ck_alloc_nozero<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 ff 00 ff   35 00 00 00   00 00 00 00   00 00 00 00   │ ····5··········· │</span><br><span class="line">00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00   │ ················ │</span><br><span class="line">00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00   │ ················ │</span><br><span class="line">00 00 00 00   00 00 00 00   00 00 00 00   00 f0 00 00   │ ················ │</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>alloc_printf</p>
<ul>
<li>User-facing macro to sprintf() to a dynamically allocated buffer<ul>
<li>ck_alloc:分配内存</li>
<li>snprintf:写入格式化字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 ff 00 ff   35 00 00 00   2f 55 73 65   72 73 2f 73   │ ····5···&#x2F;Users&#x2F;s │</span><br><span class="line">61 6b 75 72   61 2f 67 69   74 73 6f 75   72 63 65 2f   │ akura&#x2F;gitsource&#x2F; │</span><br><span class="line">41 46 4c 2f   63 6d 61 6b   65 2d 62 75   69 6c 64 2d   │ AFL&#x2F;cmake-build- │</span><br><span class="line">64 65 62 75   67 2f 61 66   6c 2d 61 73   00 f0 00 00   │ debug&#x2F;afl-as···· │</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>access</p>
<ul>
<li><code>int access(const char * pathname, int mode)</code> 检查调用进程是否可以对指定的文件执行某种操作。</li>
<li>成功执行时，返回0。失败返回-1，errno被设为以下的某个值</li>
</ul>
</li>
<li><p>strncmp</p>
</li>
<li><p><code>int strncmp ( const char * str1, const char * str2, size_t n );</code>若str1与str2的前n个字符相同，则返回0；若s1大于s2，则返回大于0的值；若s1 若小于s2，则返回小于0的值。</p>
</li>
<li><p>strcmp</p>
</li>
<li><p><code>int strcmp(const char *s1, const char *s2);</code>若参数s1 和s2 字符串相同则返回0。s1 若大于s2 则返回大于0 的值。s1 若小于s2 则返回小于0 的值。</p>
</li>
<li><p>strstr</p>
<ul>
<li><code>char *strstr(const char *haystack, const char *needle)</code>在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 ‘\0’。</li>
<li>返回该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。</li>
</ul>
</li>
<li><p>gettimeofday</p>
<ul>
<li><code>int gettimeofday(struct timeval *tv, struct timezone *tz)</code>gettimeofday()会把目前的时间用tv结构体返回，当地时区的信息则放到tz所指的结构中。</li>
<li>timeval<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_STRUCT_TIMEVAL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">__darwin_time_t</span>         tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">__darwin_suseconds_t</span>    tv_usec;        <span class="comment">/* and microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>srandom</p>
<ul>
<li>设置随机种子，注意只需要设置一次即可</li>
<li>1、生产随机数需要种子（Seed），且如果种子固定，random()每次运行生成的随机数（其实是伪随机数）也是固定的；因为返回的随机数是根据稳定的算法得出的稳定结果序列，并且Seed就是这个算法开始计算的第一个值。</li>
<li>2、srandom()可以设定种子，比如srandom(0) 、srandom(1)等等。如果srandom设定了一个固定的种子，那么random得出的随机数就是固定的；<br>如果程序运行时通过srandom(time(NULL))设定种子为随机的，那么random()每次生成的随机数就是非固定的了。</li>
</ul>
</li>
<li><p>open</p>
<ul>
<li><a href="http://c.biancheng.net/cpp/html/238.html" target="_blank" rel="noopener">open函数的简要介绍</a></li>
<li><a href="https://blog.csdn.net/csdn66_2016/article/details/77716008" target="_blank" rel="noopener">open函数返回值</a></li>
<li>调用成功时返回一个文件描述符fd，调用失败时返回-1，并修改errno</li>
</ul>
</li>
<li><p>fdopen</p>
<ul>
<li><code>FILE * fdopen(int fildes, const char * mode);</code>fdopen()会将参数fildes 的文件描述词, 转换为对应的文件指针后返回.</li>
<li>参数mode 字符串则代表着文件指针的流形态, 此形态必须和原先文件描述词读写模式相同. 关于mode字符串格式请参考fopen().</li>
<li>返回值：转换成功时返回指向该流的文件指针. 失败则返回NULL, 并把错误代码存在errno中.</li>
</ul>
</li>
<li><p>fgets</p>
<ul>
<li><code>char *fgets(char *str, int size, FILE *stream)</code>从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (size-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</li>
<li>string为一个字符数组，用来保存读取到的字符。</li>
<li>size为要读取的字符的个数。如果该行字符数大于size-1，则读到size-1个字符时结束，并在最后补充’\0’；如果该行字符数小于等于size-1，则读取所有字符，并在最后补充’\0’。即，每次最多读取size-1个字符。</li>
<li>stream为文件流指针。</li>
<li>【返回值】读取成功，返回读取到的字符串，即string；失败或读到文件结尾返回NULL。因此我们不能直接通过fgets()的返回值来判断函数是否是出错而终止的，应该借助feof()函数或者ferror()函数来判断。</li>
</ul>
</li>
<li><p>fopen</p>
<ul>
<li><code>FILE * fopen(const char * path, const char * mode);</code>打开一个文件并返回文件指针</li>
<li><a href="http://c.biancheng.net/cpp/html/250.html" target="_blank" rel="noopener">fopen参数详解</a></li>
</ul>
</li>
<li><p>atexit</p>
<ul>
<li><code>int atexit (void (*function) (void));</code>atexit()用来设置一个程序正常结束前调用的函数. 当程序通过调用exit()或从main中返回时, 参数function所指定的函数会先被调用, 然后才真正由exit()结束程序.</li>
<li>如果执行成功则返回0, 否则返回-1, 失败原因存于errno 中.</li>
</ul>
</li>
<li><p>mkdir</p>
<ul>
<li><code>int mkdir(const char *pathname, mode_t mode);</code>mkdir()函数以mode方式创建一个以pathname为名字的目录，mode定义所创建目录的权限</li>
<li>返回值: 0:目录创建成功 -1:创建失败</li>
</ul>
</li>
<li><p>flock</p>
<ul>
<li><code>int flock(int fd,int operation);</code>flock()会依参数operation所指定的方式对参数fd所指的文件做各种锁定或解除锁定的动作。此函数只能锁定整个文件，无法锁定文件的某一区域。</li>
<li>LOCK_SH 建立共享锁定。多个进程可同时对同一个文件作共享锁定。</li>
<li>LOCK_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。</li>
<li>LOCK_UN 解除文件锁定状态。</li>
<li>LOCK_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。通常与LOCK_SH或LOCK_EX 做OR(|)组合。</li>
<li>单一文件无法同时建立共享锁定和互斥锁定，而当使用dup()或fork()时文件描述词不会继承此种锁定。</li>
<li>返回值 返回0表示成功，若有错误则返回-1，错误代码存于errno。</li>
</ul>
</li>
<li><p>scandir</p>
<ul>
<li><code>int scandir(const char *dir,struct dirent **namelist,int (*filter)(const void *b),int ( * compare )( const struct dirent **, const struct dirent ** ) );</code></li>
<li><code>int alphasort(const void *a, const void *b);</code></li>
<li><code>int versionsort(const void *a, const void *b);</code></li>
<li>函数scandir扫描dir目录下(不包括子目录)满足filter过滤模式的文件，返回的结果是compare函数经过排序的，并保存在namelist中。注意namelist的元素是通过malloc动态分配内存的,所以在使用时要注意释放内存。alphasort和versionsort是使用到的两种排序的函数。 　　</li>
<li>当函数成功执行时返回找到匹配模式文件的个数，如果失败将返回-1。</li>
</ul>
</li>
<li><p>lstat</p>
<ul>
<li><code>int lstat (const char * file_name, struct stat * buf);</code></li>
<li>函数说明：lstat()与stat()作用完全相同, 都是取得参数file_name 所指的文件状态, 其差别在于, 当文件为符号连接时, lstat()会返回该link 本身的状态. 详细内容请参考stat().</li>
<li>返回值：执行成功则返回0, 失败返回-1, 错误代码存于errno.</li>
</ul>
</li>
<li><p>read</p>
<ul>
<li><code>size_t read(int fd, void * buf, size_t count);</code>read()会把参数fd所指的文件传送count个字节到buf指针所指的内存中. 若参数count为0, 则read()不会有作用并返回0.</li>
<li>返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据,此外文件读写位置会随读取到的字节移动.</li>
<li>如果顺利,read()会返回实际读到的字节数, 最好能将返回值与参数count作比较, 若返回的字节数比要求读取的字节数少, 则有可能读到了文件尾</li>
<li>当有错误发生时则返回-1, 错误代码存入errno中, 而文件读写位置则无法预期.</li>
</ul>
</li>
<li><p>sscanf</p>
<ul>
<li><code>int sscanf(const char *str, const char *format, ...)</code>从字符串读取格式化输入。</li>
<li>如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回EOF。</li>
<li>例子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>( dtm, <span class="string">"Saturday March 25 1989"</span> );</span><br><span class="line"><span class="built_in">sscanf</span>( dtm, <span class="string">"%s %s %d  %d"</span>, weekday, month, &amp;day, &amp;year );</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %d, %d = %s\n"</span>, month, day, year, weekday )</span><br><span class="line">...</span><br><span class="line">March <span class="number">25</span>, <span class="number">1989</span> = Saturday</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>link</p>
<ul>
<li><code>int link (const char * oldpath, const char * newpath);</code></li>
<li>link()以参数newpath指定的名称来建立一个新的连接(硬连接)到参数oldpath所指定的已存在文件. 如果参数newpath指定的名称为一已存在的文件则不会建立连接.</li>
<li>返回值：成功则返回0, 失败返回-1, 错误原因存于errno.</li>
</ul>
</li>
<li><p>rmdir</p>
</li>
<li><p><code>int rmdir(const char *pathname);</code>rmdir函数用于删除一个空目录。</p>
</li>
<li><p>getcwd</p>
</li>
<li><p><code>char * getcwd(char * buf, size_t size);</code>getcwd()会将当前的工作目录绝对路径复制到参数buf所指的内存空间，参数size为buf的空间大小。</p>
</li>
<li><p>unlink</p>
</li>
<li><p><code>int unlink(const char * pathname)</code>unlink()会删除参数pathname 指定的文件. 如果该文件名为最后连接点, 但有其他进程打开了此文件, 则在所有关于此文件的文件描述词皆关闭后才会删除. 如果参数pathname 为一符号连接, 则此连接会被删除。</p>
</li>
<li><p>pipe</p>
<ul>
<li><code>int pipe(int fd[2])</code>创建一个简单的管道，若成功则为数组fd分配两个文件描述符，其中fd[0]用于读取管道，fd[1]用于写入管道</li>
<li>若成功则返回零，否则返回-1，错误原因存于errno中。</li>
<li>管道，顾名思义，当我们希望将两个进程的数据连接起来的时候就可以使用它，从而将一个进程的输出数据作为另一个进程的输入数据达到通信交流的目的</li>
</ul>
</li>
<li><p>setsid</p>
</li>
<li><p>子进程从父进程继承了：SessionID、进程组ID和打开的终端。子进程如果要脱离这些，代码中可通过调用setsid来实现。而命令行或脚本中可以通过使用命令setsid来运行程序实现。setsid帮助一个进程脱离从父进程继承而来的已打开的终端、隶属进程组和隶属的会话。</p>
</li>
<li><p>dup2</p>
<ul>
<li><code>int dup2(int oldfd,int newfd);</code></li>
<li>复制一个现存的文件描述符。当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。</li>
<li>dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。</li>
</ul>
</li>
<li><p>waitpid</p>
<ul>
<li><code>pid_t waitpid(pid_t pid, int * status, int options);</code>waitpid()会暂时停止目前进程的执行, 直到有信号来到或子进程结束. 如果在调用wait()时子进程已经结束, 则wait()会立即返回子进程结束状态值. 子进程的结束状态值会由参数status返回, 而子进程的进程识别码也会一块返回. 如果不在意结束状态值, 则参数status可以设成NULL. 参数pid为欲等待的子进程识别码。</li>
<li>返回值：如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno中.</li>
</ul>
</li>
<li><p>setitimer</p>
</li>
<li><p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5984844.html" target="_blank" rel="noopener">linux几种定时函数的使用</a></p>
</li>
<li><p>mmap</p>
<ul>
<li><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)</code><br>该函数主要用途有三个：</li>
<li>将普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，用内存读写取代I/O读写，以获得较高的性能；</li>
<li>addr<ul>
<li>指向欲映射的内存起始地址，通常设为NULL，代表让系统自动选定地址，映射成功后返回该地址。</li>
</ul>
</li>
<li>length<ul>
<li>代表将文件中多大的部分映射到内存。</li>
</ul>
</li>
<li>prot<ul>
<li>PROT_EXEC 映射区域可被执行</li>
<li>PROT_READ 映射区域可被读取</li>
<li>PROT_WRITE 映射区域可被写入</li>
<li>PROT_NONE 映射区域不能存取</li>
</ul>
</li>
</ul>
</li>
<li><p>sprintf</p>
<ul>
<li><code>int sprintf(char *string, char *format [,argument,...]);</code><ul>
<li>把格式化的数据写入某个字符串中，即发送格式化输出到string所指向的字符串</li>
</ul>
</li>
</ul>
</li>
<li><p>ftruncate</p>
</li>
<li><p><code>int ftruncate(int fd, off_t  length)</code> ftruncate()会将参数fd指定的文件大小改为参数length指定的大小。参数fd为已打开的文件描述词，而且必须是以写入模式打开的文件。如果原来的文件件大小比参数length大，则超过的部分会被删去</p>
</li>
<li><p>lseek</p>
<ul>
<li><code>off_t lseek(int fildes, off_t offset, int whence);</code>每一个已打开的文件都有一个读写位置, 当打开文件时通常其读写位置是指向文件开头, 若是以附加的方式打开文件(如O_APPEND), 则读写位置会指向文件尾. 当read()或write()时, 读写位置会随之增加,lseek()便是用来控制该文件的读写位置. 参数fildes 为已打开的文件描述词, 参数offset 为根据参数whence来移动读写位置的位移数.</li>
<li>参数 whence 为下列其中一种:<ul>
<li>SEEK_SET 参数offset 即为新的读写位置.</li>
<li>SEEK_CUR 以目前的读写位置往后增加offset 个位移量.</li>
<li>SEEK_END 将读写位置指向文件尾后再增加offset 个位移量. 当whence 值为SEEK_CUR 或</li>
<li>SEEK_END 时, 参数offet 允许负值的出现.</li>
</ul>
</li>
<li>下列是特别的使用方式:<br>1) 欲将读写位置移到文件开头时:lseek(int fildes, 0, SEEK_SET);<br>2) 欲将读写位置移到文件尾时:lseek(int fildes, 0, SEEK_END);<br>3) 想要取得目前文件位置时:lseek(int fildes, 0, SEEK_CUR);</li>
<li>返回值：当调用成功时则返回目前的读写位置, 也就是距离文件开头多少个字节. 若有错误则返回-1, errno 会存放错误代码.</li>
</ul>
</li>
<li><p>readdir</p>
<ul>
<li>readdir()返回参数dir 目录流的下个目录进入点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    DIR * dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    dir = opendir(<span class="string">"/etc/rc.d"</span>);</span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"d_name : %s\n"</span>, ptr-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br><span class="line">执行：</span><br><span class="line">d_name : .</span><br><span class="line">d_name : ..</span><br><span class="line">d_name : init.d</span><br><span class="line">d_name : rc0.d</span><br><span class="line">d_name : rc1.d</span><br><span class="line">d_name : rc2.d</span><br><span class="line">d_name : rc3.d</span><br><span class="line">d_name : rc4.d</span><br><span class="line">d_name : rc5.d</span><br><span class="line">d_name : rc6.d</span><br><span class="line">d_name : rc</span><br><span class="line">d_name : rc.local</span><br><span class="line">d_name : rc.sysinit</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://forcemz.net/cxx/2019/04/29/StringFormattingTalk/" target="_blank" rel="noopener">https://forcemz.net/cxx/2019/04/29/StringFormattingTalk/</a><br><a href="http://rk700.github.io/2017/12/28/afl-internals/" target="_blank" rel="noopener">http://rk700.github.io/2017/12/28/afl-internals/</a><br><a href="http://rk700.github.io/2018/01/04/afl-mutations/" target="_blank" rel="noopener">http://rk700.github.io/2018/01/04/afl-mutations/</a></p>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ul>
<li><p>也public到了安全客，可以在我的个人主页查看<br><a href="https://www.anquanke.com/member/133369" target="_blank" rel="noopener">https://www.anquanke.com/member/133369</a></p>
</li>
<li><p>欢迎加入我的知识星球<strong>天问之路</strong>，可以获取带目录的pdf版，以及有什么问题可以提问我。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/AFL/" rel="tag"># AFL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/11/kernel_qemu/" rel="next" title="Linux kernel调试环境:10分钟开箱即用">
                <i class="fa fa-chevron-left"></i> Linux kernel调试环境:10分钟开箱即用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/20/mojo/" rel="prev" title="chrome sandbox escape case study and plaidctf2020 mojo writeup">
                chrome sandbox escape case study and plaidctf2020 mojo writeup <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sakura_heart.png"
                alt="sakura" />
            
              <p class="site-author-name" itemprop="name">sakura</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/eternalsakura" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:eternalsakura13@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/sakura1328/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/eternalsakura13" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kiprey.github.io/" title="Kiprey" target="_blank">Kiprey</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://exp101t.blogspot.com/" title="Murasaki" target="_blank">Murasaki</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://elphet.blogspot.com" title="bobb" target="_blank">bobb</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://thunderjie.github.io/" title="Thunderj" target="_blank">Thunderj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dwfault.github.io/" title="dwfalut" target="_blank">dwfalut</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://p1umer.github.io/" title="P1umer" target="_blank">P1umer</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://pcat.cc/" title="pcat" target="_blank">pcat</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-gcc小叙"><span class="nav-number">1.</span> <span class="nav-text">afl-gcc小叙</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心函数"><span class="nav-number">1.1.</span> <span class="nav-text">核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#find-as"><span class="nav-number">1.1.1.</span> <span class="nav-text">find_as</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#edit-params"><span class="nav-number">1.1.2.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main函数"><span class="nav-number">1.1.3.</span> <span class="nav-text">main函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-as小叙"><span class="nav-number">2.</span> <span class="nav-text">afl-as小叙</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心函数-1"><span class="nav-number">2.1.</span> <span class="nav-text">核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#edit-params-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-instrumentation"><span class="nav-number">2.1.2.</span> <span class="nav-text">add_instrumentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main函数-1"><span class="nav-number">2.1.3.</span> <span class="nav-text">main函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-fast-clang中叙"><span class="nav-number">3.</span> <span class="nav-text">afl-fast-clang中叙</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clang-wrapper"><span class="nav-number">3.1.</span> <span class="nav-text">clang wrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#find-obj"><span class="nav-number">3.1.1.</span> <span class="nav-text">find_obj</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#edit-params-2"><span class="nav-number">3.1.2.</span> <span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main"><span class="nav-number">3.1.3.</span> <span class="nav-text">main</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afl-llvm-pass"><span class="nav-number">3.2.</span> <span class="nav-text">afl-llvm-pass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注册pass"><span class="nav-number">3.2.1.</span> <span class="nav-text">注册pass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runOnModule"><span class="nav-number">3.2.2.</span> <span class="nav-text">runOnModule</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afl-llvm-rt"><span class="nav-number">3.3.</span> <span class="nav-text">afl-llvm-rt</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#deferred-instrumentation"><span class="nav-number">3.3.1.</span> <span class="nav-text">deferred instrumentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#persistent-mode"><span class="nav-number">3.3.2.</span> <span class="nav-text">persistent mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trace-pc-guard-mode"><span class="nav-number">3.3.3.</span> <span class="nav-text">trace-pc-guard mode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-fuzz长叙"><span class="nav-number">4.</span> <span class="nav-text">afl-fuzz长叙</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始配置"><span class="nav-number">4.1.</span> <span class="nav-text">初始配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-signal-handlers"><span class="nav-number">4.1.1.</span> <span class="nav-text">setup_signal_handlers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-asan-opts"><span class="nav-number">4.1.2.</span> <span class="nav-text">check_asan_opts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fix-up-sync"><span class="nav-number">4.1.3.</span> <span class="nav-text">fix_up_sync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#save-cmdline"><span class="nav-number">4.1.4.</span> <span class="nav-text">save_cmdline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fix-up-banner"><span class="nav-number">4.1.5.</span> <span class="nav-text">fix_up_banner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-if-tty"><span class="nav-number">4.1.6.</span> <span class="nav-text">check_if_tty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-core-count"><span class="nav-number">4.1.7.</span> <span class="nav-text">get_core_count</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-crash-handling"><span class="nav-number">4.1.8.</span> <span class="nav-text">check_crash_handling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-cpu-governor"><span class="nav-number">4.1.9.</span> <span class="nav-text">check_cpu_governor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-post"><span class="nav-number">4.1.10.</span> <span class="nav-text">setup_post</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-shm"><span class="nav-number">4.1.11.</span> <span class="nav-text">setup_shm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init-count-class16"><span class="nav-number">4.1.12.</span> <span class="nav-text">init_count_class16</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-dirs-fds"><span class="nav-number">4.1.13.</span> <span class="nav-text">setup_dirs_fds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-testcases"><span class="nav-number">4.1.14.</span> <span class="nav-text">read_testcases</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-to-queue-u8-fname-u32-len-u8-passed-det"><span class="nav-number">4.1.15.</span> <span class="nav-text">add_to_queue(u8 *fname, u32 len, u8 passed_det)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load-auto"><span class="nav-number">4.1.16.</span> <span class="nav-text">load_auto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maybe-add-auto-u8-mem-u32-len"><span class="nav-number">4.1.17.</span> <span class="nav-text">maybe_add_auto(u8 *mem, u32 len)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pivot-inputs"><span class="nav-number">4.1.18.</span> <span class="nav-text">pivot_inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load-extras"><span class="nav-number">4.1.19.</span> <span class="nav-text">load_extras</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-timeout"><span class="nav-number">4.1.20.</span> <span class="nav-text">find_timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#detect-file-args"><span class="nav-number">4.1.21.</span> <span class="nav-text">detect_file_args</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-stdio-file"><span class="nav-number">4.1.22.</span> <span class="nav-text">setup_stdio_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-binary"><span class="nav-number">4.1.23.</span> <span class="nav-text">check_binary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#perform-dry-run"><span class="nav-number">4.1.24.</span> <span class="nav-text">perform_dry_run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue"><span class="nav-number">4.1.25.</span> <span class="nav-text">u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init-forkserver"><span class="nav-number">4.1.26.</span> <span class="nav-text">init_forkserver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#has-new-bits-u8-virgin-map"><span class="nav-number">4.1.27.</span> <span class="nav-text">has_new_bits(u8 *virgin_map)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u32-count-bytes-u8-mem"><span class="nav-number">4.1.28.</span> <span class="nav-text">u32 count_bytes(u8 *mem)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-run-target-char-argv-u32-timeout"><span class="nav-number">4.1.29.</span> <span class="nav-text">u8 run_target(char **argv, u32 timeout)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#classify-counts-u64-mem"><span class="nav-number">4.1.30.</span> <span class="nav-text">classify_counts(u64 *mem)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update-bitmap-score-struct-queue-entry-q"><span class="nav-number">4.1.31.</span> <span class="nav-text">update_bitmap_score(struct queue_entry *q)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-minimize-bits-u8-dst-u8-src"><span class="nav-number">4.1.32.</span> <span class="nav-text">void minimize_bits(u8 *dst, u8 *src)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cull-queue"><span class="nav-number">4.1.33.</span> <span class="nav-text">cull_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mark-as-redundant-struct-queue-entry-q-u8-state"><span class="nav-number">4.1.34.</span> <span class="nav-text">mark_as_redundant(struct queue_entry *q, u8 state)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#show-init-stats"><span class="nav-number">4.1.35.</span> <span class="nav-text">show_init_stats</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-start-position"><span class="nav-number">4.1.36.</span> <span class="nav-text">find_start_position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-write-stats-file-double-bitmap-cvg-double-stability-double-eps"><span class="nav-number">4.1.37.</span> <span class="nav-text">void write_stats_file(double bitmap_cvg, double stability, double eps)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#save-auto"><span class="nav-number">4.1.38.</span> <span class="nav-text">save_auto</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fuzz执行"><span class="nav-number">4.2.</span> <span class="nav-text">Fuzz执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主循环"><span class="nav-number">4.2.1.</span> <span class="nav-text">主循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzz-one"><span class="nav-number">4.2.2.</span> <span class="nav-text">fuzz_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-fuzzers-char-argv"><span class="nav-number">4.2.3.</span> <span class="nav-text">sync_fuzzers(char **argv)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim-case-char-argv-struct-queue-entry-q-u8-in-buf"><span class="nav-number">4.2.4.</span> <span class="nav-text">trim_case(char **argv, struct queue_entry *q, u8 *in_buf)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u32-calculate-score-struct-queue-entry-q"><span class="nav-number">4.2.5.</span> <span class="nav-text">u32 calculate_score(struct queue_entry *q)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len"><span class="nav-number">4.2.6.</span> <span class="nav-text">u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-write-to-testcase-void-mem-u32-len"><span class="nav-number">4.2.7.</span> <span class="nav-text">void write_to_testcase(void *mem, u32 len)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault"><span class="nav-number">4.2.8.</span> <span class="nav-text">u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simplify-trace-u64-mem"><span class="nav-number">4.2.9.</span> <span class="nav-text">simplify_trace(u64 *mem)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通信和覆盖率信息的记录"><span class="nav-number">5.</span> <span class="nav-text">通信和覆盖率信息的记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键变量和常量"><span class="nav-number">5.1.</span> <span class="nav-text">关键变量和常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trampoline-fmt-64"><span class="nav-number">5.2.</span> <span class="nav-text">trampoline_fmt_64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afl-maybe-log"><span class="nav-number">5.3.</span> <span class="nav-text">__afl_maybe_log</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">6.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#other"><span class="nav-number">8.</span> <span class="nav-text">other</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sakura</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'oSjxVuchxdK82iyIiuzHtfiV-gzGzoHsz',
        appKey: 'MK8tCWwU3RWlWQdEA0wOH8Dw',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("oSjxVuchxdK82iyIiuzHtfiV-gzGzoHsz", "MK8tCWwU3RWlWQdEA0wOH8Dw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
